<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <title>TitanFoundation (Foundation Diagram v1.0)</title>

    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      :root{
        --navy:#0B2A3A;
        --navy2:#0E3348;

        --bg:#F5F7FB;
        --panel:#FFFFFF;
        --border:#E5EAF1;
        --text:#0F172A;
        --sub:#64748B;

        --teal:#0BA7A5;

        --c-room:#2563EB;   /* blue */
        --c-elev:#16A34A;   /* green */
        --c-note:#9333EA;   /* purple */

        --shadow: 0 14px 28px rgba(2,6,23,0.10);
        --shadowSoft: 0 10px 20px rgba(2,6,23,0.07);
        --ring: 0 0 0 3px rgba(11,167,165,0.18);

        --glass: rgba(255,255,255,0.72);
        --glass2: rgba(255,255,255,0.86);
        --glassBorder: rgba(226,232,240,0.70);
      }

      *{ box-sizing:border-box; }
      html, body{
        margin:0;
        height:100%;
        overflow:hidden;
        background:var(--bg);
        color:var(--text);
        font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
        -webkit-text-size-adjust: 100%;
      }

      .app{
        display:grid;
        grid-template-columns: 1fr 380px;
        height:100vh;
        min-height: 100vh;
      }

      /* ===== Canvas Zone ===== */
      .canvasZone{
        position:relative;
        overflow:hidden;
        user-select:none;
        -webkit-user-select:none;
        background:
          radial-gradient(1200px 700px at 20% 15%, rgba(11,167,165,0.10), transparent 55%),
          radial-gradient(900px 600px at 80% 70%, rgba(37,99,235,0.10), transparent 55%),
          #E9EEF5;
      }
      .viewport{
        position:absolute;
        inset:0;
        overflow:hidden;
        touch-action:none;
      }
      .stage{
        position:absolute;
        left:50%;
        top:50%;
        transform-origin: 0 0;
      }
      .sheet{
        width: var(--sheet-width, 1100px);
        height: var(--sheet-height, 780px);
        background:#fff;
        border-radius:18px;
        box-shadow: var(--shadow);
        border: 1px solid rgba(15,23,42,0.06);
        position:relative;
        overflow:hidden;
      }

      .gridSvg{
        position:absolute;
        inset:0;
        pointer-events:none;
      }
      .gridSvg .minor{ stroke: rgba(15,23,42,0.06); stroke-width:1; }
      .gridSvg .major{ stroke: rgba(15,23,42,0.10); stroke-width:1.2; }

      /* ===== Floating Toolbar ===== */
      .toolbar{
        position: fixed;
        left: 16px;
        top: 16px;
        display:flex;
        align-items:center;
        gap:10px;
        padding:10px 12px;
        border-radius: 16px;
        background: var(--glass2);
        backdrop-filter: blur(12px);
        border: 1px solid var(--glassBorder);
        box-shadow: var(--shadowSoft);
        z-index: 50;
        user-select:none;
        -webkit-user-select:none;
      }
      .toolBtn{
        display:inline-flex;
        align-items:center;
        justify-content:center;
        height:42px;
        padding:0 12px;
        border-radius: 999px;
        border:2px solid rgba(15,23,42,0.12);
        background:#fff;
        cursor:pointer;
        font-size:12px;
        font-weight:1100;
        letter-spacing:0.2px;
        color:#0B1220;
        white-space:nowrap;
        transition: transform 0.10s ease, box-shadow 0.10s ease, background 0.10s ease, border-color 0.10s ease;
      }
      .toolBtn:hover{ transform: translateY(-1px); box-shadow: 0 10px 16px rgba(2,6,23,0.10); background:#F8FAFC; }
      .toolBtn.active{
        background: linear-gradient(135deg, var(--navy2), var(--navy));
        color:#fff;
        border-color: rgba(14,51,72,0.65);
      }
      .toolBtn.room{ border-color: rgba(37,99,235,0.55); }
      .toolBtn.elev{ border-color: rgba(22,163,74,0.55); }
      .toolBtn.note{ border-color: rgba(147,51,234,0.55); }

      .tbDivider{ width:1px; height:26px; background: rgba(148,163,184,0.45); border-radius:999px; margin:0 4px; }

      /* ===== Bottom-right zoom controls ===== */
      .navTools{
        position:absolute;
        right:16px;
        bottom:16px;
        display:flex;
        flex-direction:column;
        gap:10px;
        z-index: 40;
      }
      .navCard{
        background: rgba(255,255,255,0.92);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(226,232,240,0.85);
        border-radius: 16px;
        box-shadow: var(--shadowSoft);
        padding: 10px;
        width: 230px;
      }
      .navRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
      .zBtns{ display:flex; gap:8px; flex-wrap:wrap; }
      .zBtn{
        padding:10px 11px;
        border-radius:12px;
        border:1px solid rgba(226,232,240,0.95);
        background:#fff;
        cursor:pointer;
        font-size:12px;
        font-weight:1100;
      }
      .zBtn:hover{ background:#F8FAFC; }
      .zReadout{
        font-size:12px;
        font-weight:1100;
        color: var(--navy);
        padding: 10px 11px;
        border-radius:12px;
        border:1px solid rgba(226,232,240,0.95);
        background: #fff;
        min-width: 74px;
        text-align:center;
      }
      .hint{
        margin-top:8px;
        font-size:11px;
        color: var(--sub);
        line-height:1.35;
      }

      /* ===== Shapes ===== */
      .roomRect{
        position:absolute;
        border: 3px solid rgba(37,99,235,0.85);
        border-radius: 12px;
        background: rgba(37,99,235,0.06);
        transform: translate(-50%,-50%);
        box-shadow: 0 10px 16px rgba(2,6,23,0.08);
      }
      .roomLabel{
        position:absolute;
        top: -10px;
        left: 50%;
        transform: translate(-50%,-100%);
        background: rgba(255,255,255,0.95);
        border:1px solid rgba(226,232,240,0.95);
        border-radius:999px;
        padding:6px 10px;
        font-size:12px;
        font-weight:1100;
        color:#0B1220;
        white-space:nowrap;
      }

      .elevDot{
        position:absolute;
        width: 14px;
        height: 14px;
        border-radius: 999px;
        border: 3px solid rgba(255,255,255,0.95);
        box-shadow: 0 10px 16px rgba(2,6,23,0.18);
        transform: translate(-50%,-50%);
      }
      .elevBadge{
        position:absolute;
        transform: translate(-50%,-115%);
        padding:6px 10px;
        border-radius: 999px;
        border: 1px solid rgba(226,232,240,0.95);
        background: rgba(255,255,255,0.96);
        box-shadow: 0 10px 16px rgba(2,6,23,0.10);
        font-size:12px;
        font-weight:1100;
        white-space:nowrap;
        color:#0B1220;
      }
      .elevBadge small{
        font-weight:1200;
        color: rgba(100,116,139,1);
        margin-left:6px;
      }

      .noteMarker{
        position:absolute;
        width: 30px;
        height: 30px;
        border-radius: 14px;
        background: rgba(147,51,234,0.95);
        color:#fff;
        display:flex;
        align-items:center;
        justify-content:center;
        font-weight:1300;
        font-size:12px;
        border: 2px solid rgba(255,255,255,0.95);
        box-shadow: 0 10px 18px rgba(2,6,23,0.22);
        transform: translate(-50%,-50%);
      }

      /* ===== Sidebar ===== */
      .panel{
        background: var(--panel);
        border-left: 1px solid var(--border);
        display:flex;
        flex-direction:column;
        box-shadow: -10px 0 26px rgba(2,6,23,0.05);
        height:100vh;
        min-width: 0;
        position:relative;
      }
      .panelCollapsed{
        width: 56px;
        min-width:56px;
        max-width:56px;
      }

      .pHeader{
        padding:14px 14px 12px;
        background: linear-gradient(135deg, rgba(14,165,233,0.92), rgba(37,99,235,0.92));
        color:#fff;
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
      }
      .pHeader .titleWrap{
        display:flex;
        flex-direction:column;
        gap:2px;
        min-width:0;
      }
      .pHeader .small{
        font-size:11px;
        font-weight:1100;
        letter-spacing:0.5px;
        text-transform:uppercase;
        opacity:0.9;
      }
      .pHeader .big{
        font-size:18px;
        font-weight:1300;
        line-height:1.15;
        white-space:nowrap;
        overflow:hidden;
        text-overflow:ellipsis;
      }

      .collapseBtn{
        width:40px;
        height:40px;
        border-radius:14px;
        border:1px solid rgba(255,255,255,0.22);
        background: rgba(255,255,255,0.12);
        cursor:pointer;
        display:flex;
        align-items:center;
        justify-content:center;
        flex:0 0 auto;
      }
      .collapseBtn:hover{ background: rgba(255,255,255,0.18); }

      .pScroll{
        flex:1;
        overflow:auto;
        -webkit-overflow-scrolling: touch;
        padding:14px;
        display:flex;
        flex-direction:column;
        gap:12px;
        min-width:0;
      }
      .panelCollapsed .pScroll{ display:none; }

      .card{
        background:#fff;
        border:1px solid var(--border);
        border-radius:16px;
        padding:12px;
        box-shadow: var(--shadowSoft);
      }
      .lbl{
        display:block;
        font-size:11px;
        font-weight:1100;
        text-transform:uppercase;
        color: var(--sub);
        letter-spacing:0.45px;
        margin-bottom:8px;
      }
      .inp, select, textarea{
        width:100%;
        padding:12px 12px;
        font-size:14px;
        border:1px solid var(--border);
        border-radius:14px;
        background:#fff;
        outline:none;
        color:var(--text);
      }
      textarea{ min-height:72px; resize:vertical; }
      .inp:focus, select:focus, textarea:focus{
        border-color: var(--teal);
        box-shadow: var(--ring);
      }

      .row{ display:flex; gap:10px; align-items:center; }
      .row > *{ flex:1; }

      .btn{
        padding:12px 12px;
        border-radius:14px;
        border:1px solid var(--border);
        background:#fff;
        cursor:pointer;
        font-size:13px;
        font-weight:1100;
        user-select:none;
        transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.08s ease;
        display:inline-flex;
        align-items:center;
        justify-content:center;
        gap:8px;
      }
      .btn:hover{ transform: translateY(-1px); box-shadow: 0 10px 16px rgba(2,6,23,0.08); background:#F8FAFC; }
      .btnPrimary{
        border-color: rgba(11,167,165,0.35);
        color: var(--teal);
        background: rgba(11,167,165,0.06);
      }
      .btnDanger{
        border-color: rgba(220,38,38,0.35);
        color: #B91C1C;
        background: rgba(220,38,38,0.06);
      }
      .tiny{ color: var(--sub); font-size:12px; line-height:1.35; }
      .hr{ height:1px; background: rgba(226,232,240,0.95); margin: 8px 0; }

      .listItem{
        border:1px solid rgba(226,232,240,0.95);
        border-radius:14px;
        padding:10px;
        cursor:pointer;
        background:#fff;
        display:flex;
        align-items:flex-start;
        justify-content:space-between;
        gap:10px;
      }
      .listItem:hover{ background:#F8FAFC; }
      .listItem.selected{ box-shadow: var(--ring); border-color: rgba(11,167,165,0.55); background:#F1F5F9; }
      .listItem b{ display:block; font-size:13px; font-weight:1200; }
      .listItem span{ display:block; font-size:12px; color: var(--sub); margin-top:4px; }
      .pill{
        font-size:11px;
        font-weight:1200;
        padding:4px 8px;
        border-radius:999px;
        border:1px solid rgba(226,232,240,0.95);
        background:#fff;
        white-space:nowrap;
        color:#0B1220;
      }

      /* Responsive */
      @media (max-width: 980px){
        .app{ grid-template-columns: 1fr 340px; }
      }
      @media (max-width: 820px){
        .app{ grid-template-columns: 1fr; }
        .panel{
          position:fixed;
          right:0;
          top:0;
          bottom:0;
          width:min(100%, 420px);
          transform: translateX(100%);
          transition: transform 0.2s ease;
          z-index: 70;
        }
        .panel.mobileOpen{ transform: translateX(0); }
        .panelOverlay{
          position:fixed;
          inset:0;
          background: rgba(15,23,42,0.35);
          opacity:0;
          pointer-events:none;
          transition: opacity 0.2s ease;
          z-index: 65;
        }
        .panelOverlay.show{
          opacity:1;
          pointer-events:auto;
        }
        .toolbar{ left: 12px; top: 12px; }
        .navTools{ right:12px; bottom:12px; }
        .navCard{ width: 210px; }
        .mobileDock{
          position: fixed;
          left: 12px;
          right: 12px;
          bottom: 16px;
          display:flex;
          gap:10px;
          z-index: 60;
        }
        .mobileDock .btn{ flex:1 1 0; }
      }
    </style>
  </head>

  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useEffect, useMemo, useRef, useState, useCallback } = React;

      const STORAGE_KEY = "titanfoundation.v1.state";
      const uid = () => Math.random().toString(36).slice(2,10);
      const clamp = (v, min, max) => Math.min(Math.max(v, min), max);

      function downloadText(filename, text){
        const blob = new Blob([text], { type:"application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 200);
      }

      function App(){
        const viewportRef = useRef(null);

        // View (pan/zoom)
        const [view, setView] = useState({ scale: 1.0, tx: 0, ty: 0 });
        const [viewportSize, setViewportSize] = useState({ w: window.innerWidth, h: window.innerHeight });

        // Tools
        // select | room | elev | note | pan
        const [tool, setTool] = useState("select");

        // Sheet
        const SHEET = { w: 1100, h: 780 };

        // Project data
        const [projectName, setProjectName] = useState("Enter Name");
        const [frontFaces, setFrontFaces] = useState("North");

        // Scale: feet per grid major (10px minor, 50px major). This is a simple helper, not a survey-grade scale.
        const [scaleFtPerMajor, setScaleFtPerMajor] = useState(5); // 1 major grid ~ 5 ft

        // Leak indicators (simple)
        const [leak, setLeak] = useState({
          activeLeakReported: false,
          plumbingSupplyNearby: false,
          drainLineNearby: false,
          stainingObserved: false,
          elevatedMoistureReadings: false,
          notes: ""
        });

        // Entities
        const [rooms, setRooms] = useState([]);      // {id, cx, cy, w, h, name}
        const [elevPts, setElevPts] = useState([]);  // {id, x, y, reading, label, note}
        const [notes, setNotes] = useState([]);      // {id, x, y, text}

        const [selected, setSelected] = useState({ type:null, id:null });

        // Sidebar
        const [panelCollapsed, setPanelCollapsed] = useState(false);
        const [mobilePanelOpen, setMobilePanelOpen] = useState(false);

        // Drawing / dragging state
        // drag: {mode:'pan'|'room-draw'|'move', start:{x,y}, startWorld:{x,y}, entity, origin, rectStartWorld}
        const [drag, setDrag] = useState(null);

        // Mobile detection
        useEffect(() => {
          const onResize = () => setViewportSize({ w: window.innerWidth, h: window.innerHeight });
          window.addEventListener("resize", onResize);
          return () => window.removeEventListener("resize", onResize);
        }, []);
        const isMobile = viewportSize.w <= 820;

        // World <-> screen helpers
        const screenToWorld = (clientX, clientY) => {
          const v = viewportRef.current?.getBoundingClientRect();
          if(!v) return { x:0, y:0 };
          const sx = clientX - v.left;
          const sy = clientY - v.top;
          // stage is centered at (v.width/2, v.height/2) + tx/ty, then scaled, then sheet is centered at 0,0
          // We'll treat world coords with origin at sheet center.
          const x = (sx - v.width/2 - view.tx) / view.scale;
          const y = (sy - v.height/2 - view.ty) / view.scale;
          return { x, y };
        };

        const worldToSheetPx = (wx, wy) => {
          // world origin is sheet center; convert to sheet local px
          return { x: wx + SHEET.w/2, y: wy + SHEET.h/2 };
        };

        const sheetPxToWorld = (sx, sy) => {
          return { x: sx - SHEET.w/2, y: sy - SHEET.h/2 };
        };

        const withinSheet = (sheetX, sheetY) => sheetX >= 0 && sheetY >= 0 && sheetX <= SHEET.w && sheetY <= SHEET.h;

        // Zoom helpers
        const setScaleAnchored = (nextScale, anchorClient) => {
          const v = viewportRef.current?.getBoundingClientRect();
          if(!v) return;
          const scale = clamp(nextScale, 0.35, 3.0);

          if(!anchorClient){
            setView(prev => ({ ...prev, scale }));
            return;
          }

          setView(prev => {
            const ax = anchorClient.x - v.left;
            const ay = anchorClient.y - v.top;
            const s0 = prev.scale;
            const s1 = scale;

            const tx0 = prev.tx;
            const ty0 = prev.ty;

            const dx = ax - v.width/2 - tx0;
            const dy = ay - v.height/2 - ty0;

            const tx1 = tx0 + dx * (1 - s1/s0);
            const ty1 = ty0 + dy * (1 - s1/s0);

            return { scale: s1, tx: tx1, ty: ty1 };
          });
        };

        const zoomIn = () => setScaleAnchored(view.scale * 1.15);
        const zoomOut = () => setScaleAnchored(view.scale / 1.15);
        const zoomReset = () => setView({ scale: 1.0, tx: 0, ty: 0 });

        const zoomFit = () => {
          const v = viewportRef.current?.getBoundingClientRect();
          if(!v) return;
          const pad = 90;
          const sx = (v.width - pad) / SHEET.w;
          const sy = (v.height - pad) / SHEET.h;
          const s = clamp(Math.min(sx, sy), 0.55, 3.0);
          setView({ scale: s, tx: 0, ty: 0 });
        };

        useEffect(() => { setTimeout(() => zoomFit(), 0); }, []);

        // Wheel (desktop)
        const onWheel = (e) => {
          e.preventDefault();
          const isZoom = e.ctrlKey || e.metaKey;
          if(isZoom){
            const delta = -e.deltaY;
            const factor = delta > 0 ? 1.08 : 1/1.08;
            setScaleAnchored(view.scale * factor, { x: e.clientX, y: e.clientY });
          } else {
            setView(prev => ({ ...prev, tx: prev.tx - e.deltaX, ty: prev.ty - e.deltaY }));
          }
        };

        // Pinch + two-finger pan (touch)
        const pointersRef = useRef(new Map()); // pointerId -> {x,y}
        const pinchRef = useRef(null);

        const startPinchIfTwo = () => {
          const pts = [...pointersRef.current.values()];
          if(pts.length !== 2) return;
          const [a,b] = pts;
          const dist = Math.hypot(b.x-a.x, b.y-a.y) || 1;
          const center = { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
          pinchRef.current = {
            startDist: dist,
            startScale: view.scale,
            startTx: view.tx,
            startTy: view.ty,
            centerX: center.x,
            centerY: center.y,
            lastCenterX: center.x,
            lastCenterY: center.y
          };
        };

        const updatePinch = () => {
          const pts = [...pointersRef.current.values()];
          if(pts.length !== 2 || !pinchRef.current) return;
          const [a,b] = pts;
          const dist = Math.hypot(b.x-a.x, b.y-a.y) || 1;
          const center = { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
          const ratio = dist / pinchRef.current.startDist;
          const targetScale = clamp(pinchRef.current.startScale * ratio, 0.35, 3.0);

          const dcx = center.x - pinchRef.current.lastCenterX;
          const dcy = center.y - pinchRef.current.lastCenterY;

          setView(prev => {
            const v = viewportRef.current?.getBoundingClientRect();
            if(!v) return prev;

            const ax = pinchRef.current.centerX - v.left;
            const ay = pinchRef.current.centerY - v.top;

            const s0 = pinchRef.current.startScale || 1;
            const s1 = targetScale;

            const tx0 = pinchRef.current.startTx;
            const ty0 = pinchRef.current.startTy;

            const dx0 = ax - v.width/2 - tx0;
            const dy0 = ay - v.height/2 - ty0;

            const tx1 = tx0 + dx0 * (1 - s1/s0);
            const ty1 = ty0 + dy0 * (1 - s1/s0);

            return { scale: s1, tx: tx1 + dcx, ty: ty1 + dcy };
          });

          pinchRef.current.lastCenterX = center.x;
          pinchRef.current.lastCenterY = center.y;
        };

        // Elevation summary + grading buckets
        const elevSummary = useMemo(() => {
          if(!elevPts.length) return { min:null, max:null, diff:null };
          const vals = elevPts.map(p => Number(p.reading)).filter(v => Number.isFinite(v));
          if(!vals.length) return { min:null, max:null, diff:null };
          const min = Math.min(...vals);
          const max = Math.max(...vals);
          const diff = max - min;
          return { min, max, diff };
        }, [elevPts]);

        const classifyElev = (value) => {
          const { min, max } = elevSummary;
          if(min == null || max == null || min === max) return { tag:"MID", t:0.5 };
          const t = (value - min) / (max - min); // 0..1
          if(t <= 0.33) return { tag:"LOW", t };
          if(t >= 0.67) return { tag:"HIGH", t };
          return { tag:"MID", t };
        };

        const elevColor = (value) => {
          const { min, max } = elevSummary;
          if(min == null || max == null || min === max) return "rgba(22,163,74,0.95)";
          const t = clamp((value - min) / (max - min), 0, 1);
          // green -> amber -> red-ish (simple gradient via RGB interpolation)
          // low: green, mid: amber, high: red
          const lerp = (a,b,u) => Math.round(a + (b-a)*u);
          let r,g,b;
          if(t < 0.5){
            const u = t/0.5;
            r = lerp(22, 245, u);
            g = lerp(163, 158, u);
            b = lerp(74, 11, u);
          } else {
            const u = (t-0.5)/0.5;
            r = lerp(245, 220, u);
            g = lerp(158, 38, u);
            b = lerp(11, 38, u);
          }
          return `rgba(${r},${g},${b},0.95)`;
        };

        // Save/Load
        const buildState = useCallback(() => ({
          projectName,
          frontFaces,
          scaleFtPerMajor,
          leak,
          rooms,
          elevPts,
          notes,
          view
        }), [projectName, frontFaces, scaleFtPerMajor, leak, rooms, elevPts, notes, view]);

        const saveState = useCallback((source="manual") => {
          try{
            localStorage.setItem(STORAGE_KEY, JSON.stringify(buildState()));
          }catch(e){
            console.warn("Save failed", e);
          }
        }, [buildState]);

        const loadState = useCallback(() => {
          const raw = localStorage.getItem(STORAGE_KEY);
          if(!raw) return;
          try{
            const s = JSON.parse(raw);
            setProjectName(s.projectName ?? "Enter Name");
            setFrontFaces(s.frontFaces ?? "North");
            setScaleFtPerMajor(Number.isFinite(s.scaleFtPerMajor) ? s.scaleFtPerMajor : 5);
            setLeak(s.leak ?? {
              activeLeakReported:false, plumbingSupplyNearby:false, drainLineNearby:false,
              stainingObserved:false, elevatedMoistureReadings:false, notes:""
            });
            setRooms(Array.isArray(s.rooms) ? s.rooms : []);
            setElevPts(Array.isArray(s.elevPts) ? s.elevPts : []);
            setNotes(Array.isArray(s.notes) ? s.notes : []);
            setView(s.view ?? { scale:1.0, tx:0, ty:0 });
          }catch(e){
            console.warn("Load failed", e);
          }
        }, []);

        useEffect(() => { loadState(); }, []);
        useEffect(() => {
          const id = setInterval(() => saveState("auto"), 5*60*1000);
          return () => clearInterval(id);
        }, [saveState]);

        // Selection helpers
        const selectEntity = (type, id) => {
          setSelected({ type, id });
          if(isMobile) setMobilePanelOpen(true);
        };

        const selectedEntity = useMemo(() => {
          const { type, id } = selected;
          if(!type || !id) return null;
          if(type === "room") return rooms.find(r => r.id === id) || null;
          if(type === "elev") return elevPts.find(p => p.id === id) || null;
          if(type === "note") return notes.find(n => n.id === id) || null;
          return null;
        }, [selected, rooms, elevPts, notes]);

        const updateSelected = (patch) => {
          const { type, id } = selected;
          if(!type || !id) return;
          if(type === "room"){
            setRooms(prev => prev.map(r => r.id === id ? { ...r, ...patch } : r));
          }
          if(type === "elev"){
            setElevPts(prev => prev.map(p => p.id === id ? { ...p, ...patch } : p));
          }
          if(type === "note"){
            setNotes(prev => prev.map(n => n.id === id ? { ...n, ...patch } : n));
          }
        };

        const deleteSelected = () => {
          const { type, id } = selected;
          if(!type || !id) return;
          if(type === "room") setRooms(prev => prev.filter(r => r.id !== id));
          if(type === "elev") setElevPts(prev => prev.filter(p => p.id !== id));
          if(type === "note") setNotes(prev => prev.filter(n => n.id !== id));
          setSelected({ type:null, id:null });
        };

        // Pointer handling on viewport
        const onPointerDown = (e) => {
          // Track pointers for pinch
          pointersRef.current.set(e.pointerId, { x:e.clientX, y:e.clientY });
          if(pointersRef.current.size === 2){
            startPinchIfTwo();
          }

          // If pinch is active, don't start drawing
          if(pointersRef.current.size >= 2) return;

          e.preventDefault();
          const world = screenToWorld(e.clientX, e.clientY);
          const sheet = worldToSheetPx(world.x, world.y);

          // Right now: tool can override
          if(tool === "pan"){
            setDrag({ mode:"pan", start:{ x:e.clientX, y:e.clientY }, origin:{ tx:view.tx, ty:view.ty } });
            try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
            return;
          }

          // Click outside sheet: pan
          if(!withinSheet(sheet.x, sheet.y)){
            setDrag({ mode:"pan", start:{ x:e.clientX, y:e.clientY }, origin:{ tx:view.tx, ty:view.ty } });
            try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
            return;
          }

          // If selecting, attempt hit test first
          if(tool === "select"){
            // hit test order: note -> elev -> room
            const hitNote = [...notes].reverse().find(n => {
              const dx = n.x - sheet.x, dy = n.y - sheet.y;
              return Math.hypot(dx,dy) <= 22;
            });
            if(hitNote){
              selectEntity("note", hitNote.id);
              setDrag({ mode:"move", entity:{ type:"note", id:hitNote.id }, start:{x:e.clientX,y:e.clientY}, startWorld:world });
              try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
              return;
            }

            const hitElev = [...elevPts].reverse().find(p => {
              const dx = p.x - sheet.x, dy = p.y - sheet.y;
              return Math.hypot(dx,dy) <= 18;
            });
            if(hitElev){
              selectEntity("elev", hitElev.id);
              setDrag({ mode:"move", entity:{ type:"elev", id:hitElev.id }, start:{x:e.clientX,y:e.clientY}, startWorld:world });
              try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
              return;
            }

            const hitRoom = [...rooms].reverse().find(r => {
              const left = r.cx - r.w/2, right = r.cx + r.w/2;
              const top = r.cy - r.h/2, bottom = r.cy + r.h/2;
              return sheet.x >= left && sheet.x <= right && sheet.y >= top && sheet.y <= bottom;
            });
            if(hitRoom){
              selectEntity("room", hitRoom.id);
              setDrag({ mode:"move", entity:{ type:"room", id:hitRoom.id }, start:{x:e.clientX,y:e.clientY}, startWorld:world });
              try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
              return;
            }

            // empty click clears selection
            setSelected({ type:null, id:null });
            return;
          }

          if(tool === "room"){
            // start rect draw
            const start = sheet;
            const newId = uid();
            const newRoom = { id:newId, cx:start.x, cy:start.y, w:10, h:10, name:`Room ${rooms.length+1}` };
            setRooms(prev => [...prev, newRoom]);
            selectEntity("room", newId);
            setDrag({ mode:"room-draw", id:newId, rectStartWorld: world });
            try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
            return;
          }

          if(tool === "elev"){
            const reading = prompt("Elevation reading (inches or consistent unit):", "0.00");
            if(reading == null) return;
            const val = Number(reading);
            if(!Number.isFinite(val)){
              alert("Please enter a numeric elevation reading.");
              return;
            }
            const id = uid();
            setElevPts(prev => [...prev, { id, x:sheet.x, y:sheet.y, reading: val, note:"" }]);
            selectEntity("elev", id);
            return;
          }

          if(tool === "note"){
            const text = prompt("Note text:", "");
            if(text == null) return;
            const id = uid();
            setNotes(prev => [...prev, { id, x:sheet.x, y:sheet.y, text: text || "Note" }]);
            selectEntity("note", id);
            return;
          }
        };

        const onPointerMove = (e) => {
          // pinch update
          if(pointersRef.current.has(e.pointerId)){
            pointersRef.current.set(e.pointerId, { x:e.clientX, y:e.clientY });
            if(pointersRef.current.size === 2){
              updatePinch();
              return;
            }
          }

          if(!drag) return;
          e.preventDefault();

          if(drag.mode === "pan"){
            const dx = e.clientX - drag.start.x;
            const dy = e.clientY - drag.start.y;
            setView(prev => ({ ...prev, tx: drag.origin.tx + dx, ty: drag.origin.ty + dy }));
            return;
          }

          if(drag.mode === "room-draw"){
            const world = screenToWorld(e.clientX, e.clientY);
            const sheet = worldToSheetPx(world.x, world.y);
            const startWorld = drag.rectStartWorld;
            const startSheet = worldToSheetPx(startWorld.x, startWorld.y);

            const id = drag.id;
            const left = Math.min(startSheet.x, sheet.x);
            const right = Math.max(startSheet.x, sheet.x);
            const top = Math.min(startSheet.y, sheet.y);
            const bottom = Math.max(startSheet.y, sheet.y);

            const cx = (left+right)/2;
            const cy = (top+bottom)/2;
            const w = Math.max(24, right-left);
            const h = Math.max(24, bottom-top);

            setRooms(prev => prev.map(r => r.id === id ? { ...r, cx, cy, w, h } : r));
            return;
          }

          if(drag.mode === "move"){
            const world = screenToWorld(e.clientX, e.clientY);
            const deltaWorld = { x: world.x - drag.startWorld.x, y: world.y - drag.startWorld.y };
            const deltaSheet = { x: deltaWorld.x, y: deltaWorld.y }; // since world is sheet-centered in px units
            const { type, id } = drag.entity;

            if(type === "room"){
              setRooms(prev => prev.map(r => r.id === id ? { ...r, cx: r.cx + deltaSheet.x, cy: r.cy + deltaSheet.y } : r));
            }
            if(type === "elev"){
              setElevPts(prev => prev.map(p => p.id === id ? { ...p, x: p.x + deltaSheet.x, y: p.y + deltaSheet.y } : p));
            }
            if(type === "note"){
              setNotes(prev => prev.map(n => n.id === id ? { ...n, x: n.x + deltaSheet.x, y: n.y + deltaSheet.y } : n));
            }

            // update baseline for smooth drag
            setDrag(prev => prev ? ({ ...prev, startWorld: world }) : prev);
            return;
          }
        };

        const onPointerUp = (e) => {
          // remove pointer
          pointersRef.current.delete(e.pointerId);
          if(pointersRef.current.size < 2){
            pinchRef.current = null;
          }
          if(drag){
            setDrag(null);
            try { e.currentTarget.releasePointerCapture(e.pointerId); } catch {}
          }
        };

        // Export/Import
        const exportJson = () => {
          const s = buildState();
          downloadText(`TitanFoundation_${projectName.replace(/\s+/g,"_") || "Project"}.json`, JSON.stringify(s, null, 2));
        };

        const importJson = async (file) => {
          if(!file) return;
          try{
            const text = await file.text();
            const s = JSON.parse(text);

            setProjectName(s.projectName ?? "Enter Name");
            setFrontFaces(s.frontFaces ?? "North");
            setScaleFtPerMajor(Number.isFinite(s.scaleFtPerMajor) ? s.scaleFtPerMajor : 5);
            setLeak(s.leak ?? leak);
            setRooms(Array.isArray(s.rooms) ? s.rooms : []);
            setElevPts(Array.isArray(s.elevPts) ? s.elevPts : []);
            setNotes(Array.isArray(s.notes) ? s.notes : []);
            setView(s.view ?? { scale:1.0, tx:0, ty:0 });

            setSelected({ type:null, id:null });
            if(isMobile) setMobilePanelOpen(true);
          }catch(err){
            alert("Import failed. Please verify it is a TitanFoundation JSON export.");
          }
        };

        // Derived room dimensions (approx) using scaleFtPerMajor; major grid is 50px
        const pxPerMajor = 50;
        const roomDimsText = (room) => {
          const ftPerPx = scaleFtPerMajor / pxPerMajor;
          const wFt = room.w * ftPerPx;
          const hFt = room.h * ftPerPx;
          const fmt = (v) => (Math.round(v*10)/10).toFixed(1);
          return `${fmt(wFt)} ft × ${fmt(hFt)} ft`;
        };

        // Render
        const panelClass = [
          "panel",
          panelCollapsed ? "panelCollapsed" : "",
          (isMobile && mobilePanelOpen) ? "mobileOpen" : ""
        ].join(" ").trim();

        return (
          <>
            {isMobile && (
              <div
                className={"panelOverlay " + (mobilePanelOpen ? "show" : "")}
                onClick={() => setMobilePanelOpen(false)}
              />
            )}

            <div className="toolbar">
              <button className={"toolBtn " + (tool==="select" ? "active" : "")} onClick={() => setTool("select")}>
                Select
              </button>
              <button className={"toolBtn " + (tool==="pan" ? "active" : "")} onClick={() => setTool("pan")}>
                Pan
              </button>
              <span className="tbDivider"></span>
              <button className={"toolBtn room " + (tool==="room" ? "active" : "")} onClick={() => setTool("room")}>
                Draw Room
              </button>
              <button className={"toolBtn elev " + (tool==="elev" ? "active" : "")} onClick={() => setTool("elev")}>
                Elevation
              </button>
              <button className={"toolBtn note " + (tool==="note" ? "active" : "")} onClick={() => setTool("note")}>
                Note
              </button>
              {isMobile && (
                <>
                  <span className="tbDivider"></span>
                  <button className="toolBtn" onClick={() => setMobilePanelOpen(true)}>Panel</button>
                </>
              )}
            </div>

            <div className="app">
              <div className="canvasZone" onWheel={onWheel}>
                <div
                  className="viewport"
                  ref={viewportRef}
                  onPointerDown={onPointerDown}
                  onPointerMove={onPointerMove}
                  onPointerUp={onPointerUp}
                  onPointerCancel={onPointerUp}
                >
                  <div
                    className="stage"
                    style={{
                      transform: `translate(${view.tx}px, ${view.ty}px) scale(${view.scale}) translate(${-SHEET.w/2}px, ${-SHEET.h/2}px)`
                    }}
                  >
                    <div className="sheet" style={{ "--sheet-width": `${SHEET.w}px`, "--sheet-height": `${SHEET.h}px` }}>
                      {/* Grid */}
                      <svg className="gridSvg" width={SHEET.w} height={SHEET.h}>
                        {Array.from({length: Math.floor(SHEET.w/10)+1}).map((_,i) => {
                          const x = i*10;
                          const isMajor = x % 50 === 0;
                          return <line key={"vx"+i} x1={x} y1={0} x2={x} y2={SHEET.h} className={isMajor ? "major":"minor"} />;
                        })}
                        {Array.from({length: Math.floor(SHEET.h/10)+1}).map((_,i) => {
                          const y = i*10;
                          const isMajor = y % 50 === 0;
                          return <line key={"hy"+i} x1={0} y1={y} x2={SHEET.w} y2={y} className={isMajor ? "major":"minor"} />;
                        })}
                      </svg>

                      {/* Rooms */}
                      {rooms.map(r => (
                        <div
                          key={r.id}
                          className="roomRect"
                          onPointerDown={(e) => {
                            if(tool !== "select") return;
                            e.stopPropagation();
                            selectEntity("room", r.id);
                          }}
                          style={{
                            left: r.cx,
                            top: r.cy,
                            width: r.w,
                            height: r.h
                          }}
                        >
                          <div className="roomLabel">{r.name} • {roomDimsText(r)}</div>
                        </div>
                      ))}

                      {/* Elevation points */}
                      {elevPts.map(p => {
                        const cls = classifyElev(Number(p.reading));
                        const color = elevColor(Number(p.reading));
                        return (
                          <div key={p.id} style={{ position:"absolute", left:p.x, top:p.y }}>
                            <div
                              className="elevBadge"
                              onPointerDown={(e) => {
                                if(tool !== "select") return;
                                e.stopPropagation();
                                selectEntity("elev", p.id);
                              }}
                              style={{ left:0, top:0 }}
                            >
                              {Number(p.reading).toFixed(2)} <small>{cls.tag}</small>
                            </div>
                            <div
                              className="elevDot"
                              onPointerDown={(e) => {
                                if(tool !== "select") return;
                                e.stopPropagation();
                                selectEntity("elev", p.id);
                              }}
                              style={{ left:0, top:22, background: color }}
                            />
                          </div>
                        );
                      })}

                      {/* Notes */}
                      {notes.map(n => (
                        <div
                          key={n.id}
                          className="noteMarker"
                          title={n.text}
                          onPointerDown={(e) => {
                            if(tool !== "select") return;
                            e.stopPropagation();
                            selectEntity("note", n.id);
                          }}
                          style={{ left:n.x, top:n.y }}
                        >
                          N
                        </div>
                      ))}
                    </div>
                  </div>
                </div>

                <div className="navTools">
                  <div className="navCard">
                    <div className="navRow">
                      <div className="zBtns">
                        <button className="zBtn" onClick={zoomOut}>–</button>
                        <button className="zBtn" onClick={zoomIn}>+</button>
                        <button className="zBtn" onClick={zoomReset}>Reset</button>
                        <button className="zBtn" onClick={zoomFit}>Fit</button>
                      </div>
                      <div className="zReadout">{Math.round(view.scale*100)}%</div>
                    </div>
                    <div className="hint">
                      Tip: Use two fingers to pan/zoom on iPad. Use Select to move rooms/points/notes.
                    </div>
                  </div>
                </div>
              </div>

              <div className={panelClass}>
                <div className="pHeader">
                  <div className="titleWrap" style={{ minWidth:0 }}>
                    <div className="small">TitanFoundation</div>
                    <div className="big" title={projectName}>{projectName}</div>
                  </div>
                  <button className="collapseBtn" onClick={() => setPanelCollapsed(v => !v)} title="Collapse/Expand">
                    {panelCollapsed ? "»" : "«"}
                  </button>
                </div>

                <div className="pScroll">
                  <div className="card">
                    <label className="lbl">Project</label>
                    <input className="inp" value={projectName} onChange={(e)=>setProjectName(e.target.value)} placeholder="Enter Name" />
                    <div className="row" style={{ marginTop:10 }}>
                      <div>
                        <label className="lbl">Front faces</label>
                        <select value={frontFaces} onChange={(e)=>setFrontFaces(e.target.value)}>
                          {["North","South","East","West","Northeast","Northwest","Southeast","Southwest"].map(v => (
                            <option key={v} value={v}>{v}</option>
                          ))}
                        </select>
                      </div>
                      <div>
                        <label className="lbl">Scale</label>
                        <select value={scaleFtPerMajor} onChange={(e)=>setScaleFtPerMajor(Number(e.target.value))}>
                          {[2,5,10,15,20].map(v => (
                            <option key={v} value={v}>{v} ft / major grid</option>
                          ))}
                        </select>
                      </div>
                    </div>

                    <div className="hr"></div>
                    <div className="row">
                      <button className="btn btnPrimary" onClick={() => saveState("manual")}>Save</button>
                      <button className="btn" onClick={loadState}>Load</button>
                    </div>
                    <div className="row" style={{ marginTop:10 }}>
                      <button className="btn" onClick={exportJson}>Export JSON</button>
                      <label className="btn" style={{ margin:0 }}>
                        Import JSON
                        <input type="file" accept="application/json" style={{ display:"none" }}
                          onChange={(e)=>importJson(e.target.files?.[0])}
                        />
                      </label>
                    </div>
                  </div>

                  <div className="card">
                    <label className="lbl">Elevation summary</label>
                    {elevSummary.min == null ? (
                      <div className="tiny">No elevation points yet. Use the Elevation tool to add readings around the perimeter and interior.</div>
                    ) : (
                      <>
                        <div className="row">
                          <div className="pill">Min: {elevSummary.min.toFixed(2)}</div>
                          <div className="pill">Max: {elevSummary.max.toFixed(2)}</div>
                          <div className="pill">Diff: {elevSummary.diff.toFixed(2)}</div>
                        </div>
                        <div className="tiny" style={{ marginTop:8 }}>
                          Labels are relative (LOW/MID/HIGH) based on min/max of points currently on the sheet.
                        </div>
                      </>
                    )}
                  </div>

                  <div className="card">
                    <label className="lbl">Plumbing leak indicators</label>
                    <div className="tiny">Simple field prompts to support your site narrative.</div>
                    <div style={{ marginTop:10, display:"grid", gap:8 }}>
                      {[
                        ["activeLeakReported","Active leak reported (occupant / visible)"],
                        ["plumbingSupplyNearby","Plumbing supply line nearby"],
                        ["drainLineNearby","Drain / sanitary line nearby"],
                        ["stainingObserved","Staining / efflorescence observed"],
                        ["elevatedMoistureReadings","Elevated moisture readings observed"]
                      ].map(([k,label]) => (
                        <label key={k} style={{ display:"flex", gap:10, alignItems:"center", fontSize:13, fontWeight:1000 }}>
                          <input
                            type="checkbox"
                            checked={!!leak[k]}
                            onChange={(e)=>setLeak(prev=>({ ...prev, [k]: e.target.checked }))}
                          />
                          {label}
                        </label>
                      ))}
                    </div>
                    <div style={{ marginTop:10 }}>
                      <label className="lbl">Notes</label>
                      <textarea
                        value={leak.notes}
                        onChange={(e)=>setLeak(prev=>({ ...prev, notes:e.target.value }))}
                        placeholder="Brief notes (locations, fixtures, timing, actions taken, etc.)"
                      />
                    </div>
                  </div>

                  <div className="card">
                    <label className="lbl">Items</label>

                    <div className="tiny" style={{ marginBottom:8 }}>
                      Select an item (or tap one on the sheet) to edit its details here.
                    </div>

                    {/* Rooms list */}
                    <div className="tiny" style={{ fontWeight:1200, margin:"8px 0" }}>Rooms ({rooms.length})</div>
                    {rooms.length ? rooms.map(r => (
                      <div
                        key={r.id}
                        className={"listItem " + (selected.type==="room" && selected.id===r.id ? "selected":"")}
                        onClick={()=>selectEntity("room", r.id)}
                      >
                        <div style={{ minWidth:0 }}>
                          <b>{r.name}</b>
                          <span>{roomDimsText(r)}</span>
                        </div>
                        <div className="pill">Room</div>
                      </div>
                    )) : <div className="tiny">No rooms yet. Use “Draw Room”.</div>}

                    <div className="hr"></div>

                    {/* Elevations list */}
                    <div className="tiny" style={{ fontWeight:1200, margin:"8px 0" }}>Elevations ({elevPts.length})</div>
                    {elevPts.length ? elevPts.map(p => (
                      <div
                        key={p.id}
                        className={"listItem " + (selected.type==="elev" && selected.id===p.id ? "selected":"")}
                        onClick={()=>selectEntity("elev", p.id)}
                      >
                        <div style={{ minWidth:0 }}>
                          <b>{Number(p.reading).toFixed(2)}</b>
                          <span>{(p.note || "").trim() ? p.note : "No note"}</span>
                        </div>
                        <div className="pill">Elev</div>
                      </div>
                    )) : <div className="tiny">No elevations yet. Use “Elevation”.</div>}

                    <div className="hr"></div>

                    {/* Notes list */}
                    <div className="tiny" style={{ fontWeight:1200, margin:"8px 0" }}>Notes ({notes.length})</div>
                    {notes.length ? notes.map(n => (
                      <div
                        key={n.id}
                        className={"listItem " + (selected.type==="note" && selected.id===n.id ? "selected":"")}
                        onClick={()=>selectEntity("note", n.id)}
                      >
                        <div style={{ minWidth:0 }}>
                          <b>Note</b>
                          <span>{n.text}</span>
                        </div>
                        <div className="pill">N</div>
                      </div>
                    )) : <div className="tiny">No notes yet. Use “Note”.</div>}
                  </div>

                  {/* Selected editor */}
                  <div className="card">
                    <label className="lbl">Selected</label>
                    {!selectedEntity ? (
                      <div className="tiny">Nothing selected.</div>
                    ) : (
                      <>
                        {selected.type === "room" && (
                          <>
                            <label className="lbl">Room name</label>
                            <input className="inp" value={selectedEntity.name} onChange={(e)=>updateSelected({ name:e.target.value })} />
                            <div className="tiny" style={{ marginTop:8 }}>
                              Size is drawn to scale (approx) using the “ft / major grid” setting.
                            </div>
                          </>
                        )}

                        {selected.type === "elev" && (
                          <>
                            <label className="lbl">Elevation reading</label>
                            <input
                              className="inp"
                              value={selectedEntity.reading}
                              onChange={(e)=>{
                                const v = Number(e.target.value);
                                updateSelected({ reading: Number.isFinite(v) ? v : selectedEntity.reading });
                              }}
                            />
                            <label className="lbl" style={{ marginTop:10 }}>Note</label>
                            <textarea value={selectedEntity.note || ""} onChange={(e)=>updateSelected({ note:e.target.value })} />
                          </>
                        )}

                        {selected.type === "note" && (
                          <>
                            <label className="lbl">Note text</label>
                            <textarea value={selectedEntity.text} onChange={(e)=>updateSelected({ text:e.target.value })} />
                          </>
                        )}

                        <div className="row" style={{ marginTop:10 }}>
                          <button className="btn btnDanger" onClick={deleteSelected}>Delete</button>
                          <button className="btn" onClick={()=>setSelected({ type:null, id:null })}>Clear</button>
                        </div>
                      </>
                    )}
                  </div>

                  <div className="card">
                    <label className="lbl">Quick reset</label>
                    <div className="row">
                      <button className="btn btnDanger" onClick={()=>{
                        if(!confirm("Clear the entire sheet?")) return;
                        setRooms([]); setElevPts([]); setNotes([]);
                        setSelected({ type:null, id:null });
                      }}>
                        Clear Sheet
                      </button>
                      <button className="btn" onClick={() => zoomFit()}>Fit View</button>
                    </div>
                    <div className="tiny" style={{ marginTop:8 }}>
                      Clearing the sheet does not clear the leak indicators or project header.
                    </div>
                  </div>

                </div>
              </div>
            </div>

            {isMobile && (
              <div className="mobileDock">
                <button className="btn btnPrimary" onClick={()=>setMobilePanelOpen(true)}>Open Panel</button>
                <button className="btn" onClick={()=>setTool("select")}>Select</button>
                <button className="btn" onClick={()=>setTool("pan")}>Pan</button>
              </div>
            )}
          </>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
    </script>
  </body>
</html>
