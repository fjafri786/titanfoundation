<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <title>TitanFoundation (Foundation Diagram v1.0)</title>

    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      :root{
        --navy:#0B2A3A;
        --navy2:#0E3348;

        --bg:#F5F7FB;
        --panel:#FFFFFF;
        --border:#E5EAF1;
        --text:#0F172A;
        --sub:#64748B;

        --teal:#0BA7A5;

        --c-room:#2563EB;   /* blue */
        --c-elev:#16A34A;   /* green */
        --c-note:#9333EA;   /* purple */

        --shadow: 0 8px 18px rgba(2,6,23,0.08);
        --shadowSoft: 0 6px 12px rgba(2,6,23,0.06);
        --ring: 0 0 0 3px rgba(11,167,165,0.18);

        --glass: rgba(255,255,255,0.72);
        --glass2: rgba(255,255,255,0.86);
        --glassBorder: rgba(226,232,240,0.70);
      }

      *{ box-sizing:border-box; }
      html, body{
        margin:0;
        height:100%;
        overflow:hidden;
        background:var(--bg);
        color:var(--text);
        font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
        -webkit-text-size-adjust: 100%;
      }

      .app{
        display:grid;
        grid-template-columns: 1fr 380px;
        height:100vh;
        min-height: 100vh;
      }

      /* ===== Canvas Zone ===== */
      .canvasZone{
        position:relative;
        overflow:hidden;
        user-select:none;
        -webkit-user-select:none;
        background: #EEF2F7;
      }
      .viewport{
        position:absolute;
        inset:0;
        overflow:hidden;
        touch-action:none;
      }
      .stage{
        position:absolute;
        left:50%;
        top:50%;
        transform-origin: 0 0;
      }
      .sheet{
        width: var(--sheet-width, 1100px);
        height: var(--sheet-height, 780px);
        background:#fff;
        border-radius:18px;
        box-shadow: var(--shadow);
        border: 1px solid rgba(15,23,42,0.06);
        position:relative;
        overflow:hidden;
      }

      .gridSvg{
        position:absolute;
        inset:0;
        pointer-events:none;
      }
      .gridSvg .minor{ stroke: rgba(15,23,42,0.06); stroke-width:1; }
      .gridSvg .major{ stroke: rgba(15,23,42,0.10); stroke-width:1.2; }

      /* ===== Floating Toolbar ===== */
      .toolbar{
        position: fixed;
        left: 16px;
        top: 16px;
        display:flex;
        align-items:center;
        gap:10px;
        padding:10px 12px;
        background: #fff;
        border: 1px solid var(--glassBorder);
        box-shadow: var(--shadowSoft);
        z-index: 50;
        user-select:none;
        -webkit-user-select:none;
        border-radius: 18px;
      }
      .toolbar.dragging{ cursor: grabbing; }
      .toolbarHandle{
        width: 28px;
        height: 28px;
        border-radius: 10px;
        border:1px dashed rgba(148,163,184,0.9);
        display:flex;
        align-items:center;
        justify-content:center;
        font-size:14px;
        cursor: grab;
        color: rgba(100,116,139,1);
      }
      .toolbarHandle.locked{
        cursor: not-allowed;
        opacity: 0.6;
        border-style: solid;
      }
      .toolbarMenu{
        position:absolute;
        left: 10px;
        top: calc(100% + 10px);
        background:#fff;
        border:1px solid rgba(226,232,240,0.95);
        box-shadow: var(--shadowSoft);
        padding:8px;
        display:grid;
        gap:8px;
        border-radius: 16px;
        min-width: 240px;
      }
      .toolbarMenu .menuRow{
        display:flex;
        gap:8px;
        flex-wrap:wrap;
      }
      .toolbarMenu .menuBtn{
        border-radius: 12px;
        border:1px solid rgba(226,232,240,0.95);
        background:#fff;
        padding:8px 10px;
        font-size:11px;
        font-weight:1200;
        cursor:pointer;
      }
      .toolbarMenu .menuBtn.active{
        background: rgba(37,99,235,0.08);
        border-color: rgba(37,99,235,0.45);
        color: rgba(30,64,175,1);
      }
      .toolBtn{
        display:inline-flex;
        align-items:center;
        justify-content:center;
        height:42px;
        padding:0 12px;
        border-radius: 18px;
        border:2px solid rgba(15,23,42,0.12);
        background:#fff;
        cursor:pointer;
        font-size:12px;
        font-weight:1100;
        letter-spacing:0.2px;
        color:#0B1220;
        white-space:nowrap;
        transition: transform 0.10s ease, box-shadow 0.10s ease, background 0.10s ease, border-color 0.10s ease;
      }
      .toolBtn:hover{ transform: translateY(-1px); box-shadow: 0 10px 16px rgba(2,6,23,0.10); background:#F8FAFC; }
      .toolBtn.active{
        background: linear-gradient(135deg, var(--navy2), var(--navy));
        color:#fff;
        border-color: rgba(14,51,72,0.65);
      }
      .toolBtn.room{ border-color: rgba(37,99,235,0.55); }
      .toolBtn.elev{ border-color: rgba(22,163,74,0.55); }
      .toolBtn.note{ border-color: rgba(147,51,234,0.55); }
      .toolBtn.item{ border-color: rgba(15,118,110,0.55); }

      .tbDivider{ width:1px; height:26px; background: rgba(148,163,184,0.45); border-radius:999px; margin:0 4px; }

      /* ===== Bottom-right zoom controls ===== */
      .navTools{
        position:absolute;
        right:16px;
        bottom:16px;
        display:flex;
        flex-direction:column;
        gap:10px;
        z-index: 40;
      }
      .navCard{
        background: rgba(255,255,255,0.92);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(226,232,240,0.85);
        border-radius: 16px;
        box-shadow: var(--shadowSoft);
        padding: 10px;
        width: 230px;
      }
      .navRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
      .zBtns{ display:flex; gap:8px; flex-wrap:wrap; }
      .zBtn{
        padding:10px 11px;
        border-radius:12px;
        border:1px solid rgba(226,232,240,0.95);
        background:#fff;
        cursor:pointer;
        font-size:12px;
        font-weight:1100;
      }
      .zBtn:hover{ background:#F8FAFC; }
      .zReadout{
        font-size:12px;
        font-weight:1100;
        color: var(--navy);
        padding: 10px 11px;
        border-radius:12px;
        border:1px solid rgba(226,232,240,0.95);
        background: #fff;
        min-width: 74px;
        text-align:center;
      }
      .hint{
        margin-top:8px;
        font-size:11px;
        color: var(--sub);
        line-height:1.35;
      }

      /* ===== Shapes ===== */
      .spaceRect{
        position:absolute;
        border: 2px solid rgba(37,99,235,0.9);
        background: rgba(37,99,235,0.04);
        transform: translate(-50%,-50%);
      }
      .spaceRect.boundary{
        border-style: dashed;
        border-color: rgba(15,23,42,0.7);
        background: rgba(15,23,42,0.02);
      }
      .spaceRect.hallway{
        border-color: rgba(14,165,233,0.85);
        background: rgba(14,165,233,0.06);
      }
      .spaceRect.partial{
        border-style: dotted;
        border-color: rgba(100,116,139,0.8);
        background: rgba(148,163,184,0.12);
      }
      .spaceRect.locked{
        border-color: rgba(148,163,184,0.9);
      }
      .roomLabel{
        position:absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%,-50%);
        background: rgba(255,255,255,0.92);
        border:1px solid rgba(226,232,240,0.95);
        padding:6px 10px;
        font-size:11px;
        font-weight:1100;
        color:#0B1220;
        display:flex;
        gap:8px;
        align-items:center;
        white-space:nowrap;
        border-radius: 12px;
      }
      .roomLabel .roomName{ font-weight:1200; }
      .roomLabel .roomMeta{ color: rgba(100,116,139,1); }
      .roomLabel .roomKind{
        font-size:10px;
        padding:2px 6px;
        border:1px solid rgba(226,232,240,0.95);
        background:#fff;
        color:#0B1220;
      }

      .elevDot{
        position:absolute;
        width: 12px;
        height: 12px;
        border: 3px solid rgba(255,255,255,0.95);
        transform: translate(-50%,-50%);
      }
      .elevBadge{
        position:absolute;
        transform: translate(-50%,-115%);
        padding:6px 8px;
        border: 1px solid rgba(226,232,240,0.95);
        background: #fff;
        font-size:11px;
        font-weight:1100;
        white-space:nowrap;
        color:#0B1220;
        display:flex;
        gap:6px;
        align-items:center;
      }
      .elevBadge small{
        font-weight:1200;
        color: rgba(100,116,139,1);
        margin-left:0;
      }

      .noteMarker{
        position:absolute;
        width: 30px;
        height: 30px;
        background: rgba(147,51,234,0.9);
        color:#fff;
        display:flex;
        align-items:center;
        justify-content:center;
        font-weight:1300;
        font-size:12px;
        border: 2px solid rgba(255,255,255,0.95);
        transform: translate(-50%,-50%);
        border-radius: 12px;
      }

      .roomHandle{
        position:absolute;
        width: 10px;
        height: 10px;
        background:#fff;
        border:2px solid rgba(37,99,235,0.9);
        border-radius: 999px;
      }
      .roomHandle.br{ right:-6px; bottom:-6px; cursor: se-resize; }
      .roomHandle.bl{ left:-6px; bottom:-6px; cursor: sw-resize; }
      .roomHandle.tr{ right:-6px; top:-6px; cursor: ne-resize; }
      .roomHandle.tl{ left:-6px; top:-6px; cursor: nw-resize; }

      .sideToggle{
        position: fixed;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        width: 48px;
        height: 48px;
        border-radius: 18px;
        background: #0B2A3A;
        color: #fff;
        border: none;
        box-shadow: var(--shadowSoft);
        cursor:pointer;
        z-index: 80;
      }

      .fixtureRect,
      .openingRect{
        position:absolute;
        transform: translate(-50%,-50%);
        border: 2px solid rgba(15,23,42,0.7);
        background: rgba(248,250,252,0.9);
        display:flex;
        align-items:center;
        justify-content:center;
        text-align:center;
        padding:4px;
      }
      .openingRect{
        border-style: dashed;
        background: rgba(226,232,240,0.7);
      }
      .fixtureRect.locked,
      .openingRect.locked{
        border-color: rgba(148,163,184,0.9);
      }
      .fixtureLabel{
        font-size:10px;
        font-weight:1200;
        color:#0B1220;
        text-transform:uppercase;
      }

      .measureSvg{
        position:absolute;
        inset:0;
        pointer-events:none;
      }
      .measureSvg g{ pointer-events:auto; }
      .measureLine{
        stroke: rgba(15,23,42,0.9);
        stroke-width:2;
        stroke-dasharray: 6 4;
      }
      .measureLine.draft{
        stroke: rgba(100,116,139,0.6);
      }
      .measureLabel{
        font-size:10px;
        font-weight:1200;
        fill: rgba(15,23,42,0.9);
        paint-order: stroke;
        stroke: #fff;
        stroke-width: 3;
      }
      .heatSvg{
        position:absolute;
        inset:0;
        pointer-events:none;
        mix-blend-mode:multiply;
      }

      /* ===== Sidebar ===== */
      .panel{
        background: var(--panel);
        border-left: 1px solid var(--border);
        display:flex;
        flex-direction:column;
        box-shadow: -10px 0 26px rgba(2,6,23,0.05);
        height:100vh;
        min-width: 0;
        position:relative;
      }
      .panelCollapsed{
        width: 0;
        min-width:0;
        max-width:0;
        border-left: none;
        box-shadow:none;
      }

      .pHeader{
        padding:14px 14px 12px;
        background: #0B2A3A;
        color:#fff;
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
      }
      .pHeaderActions{
        display:flex;
        align-items:center;
        gap:8px;
      }
      .headerBtn{
        width:36px;
        height:36px;
        border-radius:12px;
        border:1px solid rgba(255,255,255,0.22);
        background: rgba(255,255,255,0.12);
        color:#fff;
        cursor:pointer;
        display:flex;
        align-items:center;
        justify-content:center;
      }
      .headerBtn:hover{ background: rgba(255,255,255,0.18); }
      .pHeader .titleWrap{
        display:flex;
        flex-direction:column;
        gap:2px;
        min-width:0;
      }
      .pHeader .small{
        font-size:11px;
        font-weight:1100;
        letter-spacing:0.5px;
        text-transform:uppercase;
        opacity:0.9;
      }
      .pHeader .big{
        font-size:18px;
        font-weight:1300;
        line-height:1.15;
        white-space:nowrap;
        overflow:hidden;
        text-overflow:ellipsis;
      }

      .collapseBtn{
        width:40px;
        height:40px;
        border-radius:14px;
        border:1px solid rgba(255,255,255,0.22);
        background: rgba(255,255,255,0.12);
        cursor:pointer;
        display:flex;
        align-items:center;
        justify-content:center;
        flex:0 0 auto;
      }
      .collapseBtn:hover{ background: rgba(255,255,255,0.18); }

      .pScroll{
        flex:1;
        overflow:auto;
        -webkit-overflow-scrolling: touch;
        padding:14px;
        display:flex;
        flex-direction:column;
        gap:12px;
        min-width:0;
      }
      .panelCollapsed .pScroll{ display:none; }
      .panelCollapsed .pHeader{ display:none; }

      .card{
        background:#fff;
        border:1px solid var(--border);
        border-radius:16px;
        padding:12px;
        box-shadow: var(--shadowSoft);
      }
      .lbl{
        display:block;
        font-size:11px;
        font-weight:1100;
        text-transform:uppercase;
        color: var(--sub);
        letter-spacing:0.45px;
        margin-bottom:8px;
      }
      .inp, select, textarea{
        width:100%;
        padding:12px 12px;
        font-size:14px;
        border:1px solid var(--border);
        border-radius:14px;
        background:#fff;
        outline:none;
        color:var(--text);
      }
      textarea{ min-height:72px; resize:vertical; }
      .inp:focus, select:focus, textarea:focus{
        border-color: var(--teal);
        box-shadow: var(--ring);
      }

      .row{ display:flex; gap:10px; align-items:center; }
      .row > *{ flex:1; }

      .btn{
        padding:12px 12px;
        border-radius:14px;
        border:1px solid var(--border);
        background:#fff;
        cursor:pointer;
        font-size:13px;
        font-weight:1100;
        user-select:none;
        transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.08s ease;
        display:inline-flex;
        align-items:center;
        justify-content:center;
        gap:8px;
      }
      .btn:hover{ transform: translateY(-1px); box-shadow: 0 10px 16px rgba(2,6,23,0.08); background:#F8FAFC; }
      .btnPrimary{
        border-color: rgba(11,167,165,0.35);
        color: var(--teal);
        background: rgba(11,167,165,0.06);
      }
      .btnDanger{
        border-color: rgba(220,38,38,0.35);
        color: #B91C1C;
        background: rgba(220,38,38,0.06);
      }
      .tiny{ color: var(--sub); font-size:12px; line-height:1.35; }
      .hr{ height:1px; background: rgba(226,232,240,0.95); margin: 8px 0; }

      .listItem{
        border:1px solid rgba(226,232,240,0.95);
        border-radius:14px;
        padding:10px;
        cursor:pointer;
        background:#fff;
        display:flex;
        align-items:flex-start;
        justify-content:space-between;
        gap:10px;
      }
      .listItem:hover{ background:#F8FAFC; }
      .listItem.selected{ box-shadow: var(--ring); border-color: rgba(11,167,165,0.55); background:#F1F5F9; }
      .listItem b{ display:block; font-size:13px; font-weight:1200; }
      .listItem span{ display:block; font-size:12px; color: var(--sub); margin-top:4px; }
      .pill{
        font-size:11px;
        font-weight:1200;
        padding:4px 8px;
        border:1px solid rgba(226,232,240,0.95);
        background:#fff;
        white-space:nowrap;
        color:#0B1220;
      }

      details.section{
        border:1px solid var(--border);
        background:#fff;
      }
      details.section summary{
        cursor:pointer;
        list-style:none;
        padding:10px 12px;
        font-size:12px;
        font-weight:1200;
        text-transform:uppercase;
        letter-spacing:0.4px;
        color: var(--sub);
        border-bottom:1px solid var(--border);
      }
      details.section summary::-webkit-details-marker{ display:none; }
      details.section[open] summary{
        color:#0B1220;
        background:#F8FAFC;
      }
      details.section .sectionBody{
        padding:12px;
        display:grid;
        gap:10px;
      }

      /* Responsive */
      @media (max-width: 980px){
        .app{ grid-template-columns: 1fr 340px; }
      }
      @media (max-width: 820px){
        .app{ grid-template-columns: 1fr; }
        .panel{
          position:fixed;
          right:0;
          top:0;
          bottom:0;
          width:min(100%, 420px);
          transform: translateX(100%);
          transition: transform 0.2s ease;
          z-index: 70;
        }
        .panel.mobileOpen{ transform: translateX(0); }
        .panelOverlay{
          position:fixed;
          inset:0;
          background: rgba(15,23,42,0.35);
          opacity:0;
          pointer-events:none;
          transition: opacity 0.2s ease;
          z-index: 65;
        }
        .panelOverlay.show{
          opacity:1;
          pointer-events:auto;
        }
        .toolbar{ left: 12px; top: 12px; }
        .navTools{ right:12px; bottom:12px; }
        .navCard{ width: 210px; }
        .mobileDock{
          position: fixed;
          left: 12px;
          right: 12px;
          bottom: 16px;
          display:flex;
          gap:10px;
          z-index: 60;
        }
        .mobileDock .btn{ flex:1 1 0; }
      }
    </style>
  </head>

  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useEffect, useMemo, useRef, useState, useCallback } = React;

      const STORAGE_KEY = "titanfoundation.v1.state";
      const uid = () => Math.random().toString(36).slice(2,10);
      const clamp = (v, min, max) => Math.min(Math.max(v, min), max);

      function downloadText(filename, text){
        const blob = new Blob([text], { type:"application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 200);
      }

      function App(){
        const viewportRef = useRef(null);

        // View (pan/zoom)
        const [view, setView] = useState({ scale: 1.0, tx: 0, ty: 0 });
        const [viewportSize, setViewportSize] = useState({ w: window.innerWidth, h: window.innerHeight });

        // Tools
        // select | draw | elev | observation | pan | fixture | opening | measure
        const [tool, setTool] = useState("select");
        const [drawType, setDrawType] = useState("room");
        const [draftElevation, setDraftElevation] = useState({ reading: 0.0, note: "" });
        const [draftObservation, setDraftObservation] = useState({ category: "Observation", text: "", caption: "", photo: "" });
        const [draftFixture, setDraftFixture] = useState({ kind: "Washer", label: "Washer", w: 40, h: 40 });
        const [draftOpening, setDraftOpening] = useState({ kind: "Door", label: "Door", w: 44, h: 14 });
        const [measureDraft, setMeasureDraft] = useState(null);
        const [showHeatmap, setShowHeatmap] = useState(true);
        const [zeroMode, setZeroMode] = useState("auto");
        const [customZero, setCustomZero] = useState(0);

        const observationOptions = [
          "Observation",
          "Drywall separation",
          "Mortar joint crack",
          "Wall crack",
          "Slab crack",
          "Settlement/offset",
          "Moisture staining",
          "Leak indicator",
          "Other"
        ];

        // Sheet
        const SHEET = { w: 1100, h: 780 };

        // Project data
        const [projectName, setProjectName] = useState("Enter Name");
        const [frontFaces, setFrontFaces] = useState("North");

        // Scale: feet per grid major (10px minor, 50px major). This is a simple helper, not a survey-grade scale.
        const [scaleFtPerMajor, setScaleFtPerMajor] = useState(5); // 1 major grid ~ 5 ft

        // Leak indicators (simple)
        const [leak, setLeak] = useState({
          activeLeakReported: false,
          plumbingSupplyNearby: false,
          drainLineNearby: false,
          stainingObserved: false,
          elevatedMoistureReadings: false,
          notes: ""
        });

        // Entities
        const [rooms, setRooms] = useState([]);      // {id, cx, cy, w, h, name, kind, locked, caption, notes, photo}
        const [elevPts, setElevPts] = useState([]);  // {id, x, y, reading, note, caption, photo, locked}
        const [notes, setNotes] = useState([]);      // {id, x, y, category, text, caption, photo}
        const [fixtures, setFixtures] = useState([]); // {id, x, y, w, h, kind, label, locked}
        const [openings, setOpenings] = useState([]); // {id, x, y, w, h, kind, label, locked}
        const [measurements, setMeasurements] = useState([]); // {id, x1, y1, x2, y2}

        const [selected, setSelected] = useState({ type:null, id:null });

        // Sidebar
        const [panelCollapsed, setPanelCollapsed] = useState(false);
        const [mobilePanelOpen, setMobilePanelOpen] = useState(false);
        const [panelExpanded, setPanelExpanded] = useState(false);

        // Toolbar drag/lock
        const [toolbarPos, setToolbarPos] = useState({ x: 16, y: 16 });
        const [toolbarLocked, setToolbarLocked] = useState(false);
        const [toolbarCollapsed, setToolbarCollapsed] = useState(false);

        // Drawing / dragging state
        // drag: {mode:'pan'|'room-draw'|'move'|'resize-room', start:{x,y}, startWorld:{x,y}, entity, origin, rectStartWorld}
        const [drag, setDrag] = useState(null);

        // Mobile detection
        useEffect(() => {
          const onResize = () => setViewportSize({ w: window.innerWidth, h: window.innerHeight });
          window.addEventListener("resize", onResize);
          return () => window.removeEventListener("resize", onResize);
        }, []);
        const isMobile = viewportSize.w <= 820;

        useEffect(() => {
          if(tool !== "measure") setMeasureDraft(null);
        }, [tool]);

        useEffect(() => {
          if(!drag || drag.mode !== "toolbar-drag") return;
          const onMove = (e) => {
            const dx = e.clientX - drag.start.x;
            const dy = e.clientY - drag.start.y;
            setToolbarPos({
              x: clamp(drag.origin.x + dx, 8, viewportSize.w - 280),
              y: clamp(drag.origin.y + dy, 8, viewportSize.h - 80)
            });
          };
          const onUp = () => setDrag(null);
          window.addEventListener("pointermove", onMove);
          window.addEventListener("pointerup", onUp);
          return () => {
            window.removeEventListener("pointermove", onMove);
            window.removeEventListener("pointerup", onUp);
          };
        }, [drag, viewportSize.w, viewportSize.h]);

        // World <-> screen helpers
        const screenToWorld = (clientX, clientY) => {
          const v = viewportRef.current?.getBoundingClientRect();
          if(!v) return { x:0, y:0 };
          const sx = clientX - v.left;
          const sy = clientY - v.top;
          // stage is centered at (v.width/2, v.height/2) + tx/ty, then scaled, then sheet is centered at 0,0
          // We'll treat world coords with origin at sheet center.
          const x = (sx - v.width/2 - view.tx) / view.scale;
          const y = (sy - v.height/2 - view.ty) / view.scale;
          return { x, y };
        };

        const worldToSheetPx = (wx, wy) => {
          // world origin is sheet center; convert to sheet local px
          return { x: wx + SHEET.w/2, y: wy + SHEET.h/2 };
        };

        const sheetPxToWorld = (sx, sy) => {
          return { x: sx - SHEET.w/2, y: sy - SHEET.h/2 };
        };

        const withinSheet = (sheetX, sheetY) => sheetX >= 0 && sheetY >= 0 && sheetX <= SHEET.w && sheetY <= SHEET.h;

        const boundaryRoom = useMemo(
          () => rooms.find(r => r.kind === "boundary") || null,
          [rooms]
        );
        const boundaryRect = useMemo(() => {
          if(!boundaryRoom) return null;
          return {
            left: boundaryRoom.cx - boundaryRoom.w/2,
            right: boundaryRoom.cx + boundaryRoom.w/2,
            top: boundaryRoom.cy - boundaryRoom.h/2,
            bottom: boundaryRoom.cy + boundaryRoom.h/2
          };
        }, [boundaryRoom]);
        const isPointInsideBoundary = (x, y) => {
          if(!boundaryRect) return true;
          return x >= boundaryRect.left && x <= boundaryRect.right && y >= boundaryRect.top && y <= boundaryRect.bottom;
        };
        const clampRoomToBoundary = (room) => {
          if(!boundaryRect || room.kind === "boundary") return room;
          const left = room.cx - room.w/2;
          const right = room.cx + room.w/2;
          const top = room.cy - room.h/2;
          const bottom = room.cy + room.h/2;
          let dx = 0;
          let dy = 0;
          if(left < boundaryRect.left) dx = boundaryRect.left - left;
          if(right > boundaryRect.right) dx = boundaryRect.right - right;
          if(top < boundaryRect.top) dy = boundaryRect.top - top;
          if(bottom > boundaryRect.bottom) dy = boundaryRect.bottom - bottom;
          return { ...room, cx: room.cx + dx, cy: room.cy + dy };
        };

        // Zoom helpers
        const setScaleAnchored = (nextScale, anchorClient) => {
          const v = viewportRef.current?.getBoundingClientRect();
          if(!v) return;
          const scale = clamp(nextScale, 0.35, 3.0);

          if(!anchorClient){
            setView(prev => ({ ...prev, scale }));
            return;
          }

          setView(prev => {
            const ax = anchorClient.x - v.left;
            const ay = anchorClient.y - v.top;
            const s0 = prev.scale;
            const s1 = scale;

            const tx0 = prev.tx;
            const ty0 = prev.ty;

            const dx = ax - v.width/2 - tx0;
            const dy = ay - v.height/2 - ty0;

            const tx1 = tx0 + dx * (1 - s1/s0);
            const ty1 = ty0 + dy * (1 - s1/s0);

            return { scale: s1, tx: tx1, ty: ty1 };
          });
        };

        const zoomIn = () => setScaleAnchored(view.scale * 1.15);
        const zoomOut = () => setScaleAnchored(view.scale / 1.15);
        const zoomReset = () => setView({ scale: 1.0, tx: 0, ty: 0 });

        const zoomFit = () => {
          const v = viewportRef.current?.getBoundingClientRect();
          if(!v) return;
          const pad = 90;
          const sx = (v.width - pad) / SHEET.w;
          const sy = (v.height - pad) / SHEET.h;
          const s = clamp(Math.min(sx, sy), 0.55, 3.0);
          setView({ scale: s, tx: 0, ty: 0 });
        };

        useEffect(() => { setTimeout(() => zoomFit(), 0); }, []);

        // Wheel (desktop)
        const onWheel = (e) => {
          e.preventDefault();
          const isZoom = e.ctrlKey || e.metaKey;
          if(isZoom){
            const delta = -e.deltaY;
            const factor = delta > 0 ? 1.08 : 1/1.08;
            setScaleAnchored(view.scale * factor, { x: e.clientX, y: e.clientY });
          } else {
            setView(prev => ({ ...prev, tx: prev.tx - e.deltaX, ty: prev.ty - e.deltaY }));
          }
        };

        // Pinch + two-finger pan (touch)
        const pointersRef = useRef(new Map()); // pointerId -> {x,y}
        const pinchRef = useRef(null);

        const startPinchIfTwo = () => {
          const pts = [...pointersRef.current.values()];
          if(pts.length !== 2) return;
          const [a,b] = pts;
          const dist = Math.hypot(b.x-a.x, b.y-a.y) || 1;
          const center = { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
          pinchRef.current = {
            startDist: dist,
            startScale: view.scale,
            startTx: view.tx,
            startTy: view.ty,
            centerX: center.x,
            centerY: center.y,
            lastCenterX: center.x,
            lastCenterY: center.y
          };
        };

        const updatePinch = () => {
          const pts = [...pointersRef.current.values()];
          if(pts.length !== 2 || !pinchRef.current) return;
          const [a,b] = pts;
          const dist = Math.hypot(b.x-a.x, b.y-a.y) || 1;
          const center = { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
          const ratio = dist / pinchRef.current.startDist;
          const targetScale = clamp(pinchRef.current.startScale * ratio, 0.35, 3.0);

          const dcx = center.x - pinchRef.current.lastCenterX;
          const dcy = center.y - pinchRef.current.lastCenterY;

          setView(prev => {
            const v = viewportRef.current?.getBoundingClientRect();
            if(!v) return prev;

            const ax = pinchRef.current.centerX - v.left;
            const ay = pinchRef.current.centerY - v.top;

            const s0 = pinchRef.current.startScale || 1;
            const s1 = targetScale;

            const tx0 = pinchRef.current.startTx;
            const ty0 = pinchRef.current.startTy;

            const dx0 = ax - v.width/2 - tx0;
            const dy0 = ay - v.height/2 - ty0;

            const tx1 = tx0 + dx0 * (1 - s1/s0);
            const ty1 = ty0 + dy0 * (1 - s1/s0);

            return { scale: s1, tx: tx1 + dcx, ty: ty1 + dcy };
          });

          pinchRef.current.lastCenterX = center.x;
          pinchRef.current.lastCenterY = center.y;
        };

        // Elevation summary + grading buckets
        const elevSummary = useMemo(() => {
          if(!elevPts.length) return { min:null, max:null, diff:null, mid:null };
          const vals = elevPts.map(p => Number(p.reading)).filter(v => Number.isFinite(v));
          if(!vals.length) return { min:null, max:null, diff:null, mid:null };
          const min = Math.min(...vals);
          const max = Math.max(...vals);
          const diff = max - min;
          const mid = min + diff / 2;
          return { min, max, diff, mid };
        }, [elevPts]);

        const zeroRef = useMemo(() => {
          if(zeroMode === "custom") return Number(customZero) || 0;
          return Number.isFinite(elevSummary.mid) ? elevSummary.mid : 0;
        }, [zeroMode, customZero, elevSummary.mid]);

        const classifyElev = (value) => {
          const { min, max } = elevSummary;
          if(min == null || max == null || min === max) return { tag:"MID", t:0.5 };
          const t = (value - min) / (max - min); // 0..1
          if(t <= 0.33) return { tag:"LOW", t };
          if(t >= 0.67) return { tag:"HIGH", t };
          return { tag:"MID", t };
        };

        const elevColor = (value) => {
          const { min, max } = elevSummary;
          if(min == null || max == null || min === max) return "rgba(22,163,74,0.95)";
          const t = clamp((value - min) / (max - min), 0, 1);
          // green -> amber -> red-ish (simple gradient via RGB interpolation)
          // low: green, mid: amber, high: red
          const lerp = (a,b,u) => Math.round(a + (b-a)*u);
          let r,g,b;
          if(t < 0.5){
            const u = t/0.5;
            r = lerp(22, 245, u);
            g = lerp(163, 158, u);
            b = lerp(74, 11, u);
          } else {
            const u = (t-0.5)/0.5;
            r = lerp(245, 220, u);
            g = lerp(158, 38, u);
            b = lerp(11, 38, u);
          }
          return `rgba(${r},${g},${b},0.95)`;
        };

        // Save/Load
        const buildState = useCallback(() => ({
          projectName,
          frontFaces,
          scaleFtPerMajor,
          leak,
          rooms,
          elevPts,
          notes,
          fixtures,
          openings,
          measurements,
          drawType,
          view
        }), [projectName, frontFaces, scaleFtPerMajor, leak, rooms, elevPts, notes, fixtures, openings, measurements, drawType, view]);

        const saveState = useCallback((source="manual") => {
          try{
            localStorage.setItem(STORAGE_KEY, JSON.stringify(buildState()));
          }catch(e){
            console.warn("Save failed", e);
          }
        }, [buildState]);

        const loadState = useCallback(() => {
          const raw = localStorage.getItem(STORAGE_KEY);
          if(!raw) return;
          try{
            const s = JSON.parse(raw);
            setProjectName(s.projectName ?? "Enter Name");
            setFrontFaces(s.frontFaces ?? "North");
            setScaleFtPerMajor(Number.isFinite(s.scaleFtPerMajor) ? s.scaleFtPerMajor : 5);
            setLeak(s.leak ?? {
              activeLeakReported:false, plumbingSupplyNearby:false, drainLineNearby:false,
              stainingObserved:false, elevatedMoistureReadings:false, notes:""
            });
            setRooms(Array.isArray(s.rooms) ? s.rooms : []);
            setElevPts(Array.isArray(s.elevPts) ? s.elevPts : []);
            setNotes(Array.isArray(s.notes) ? s.notes : []);
            setFixtures(Array.isArray(s.fixtures) ? s.fixtures : []);
            setOpenings(Array.isArray(s.openings) ? s.openings : []);
            setMeasurements(Array.isArray(s.measurements) ? s.measurements : []);
            setDrawType(s.drawType ?? "room");
            setView(s.view ?? { scale:1.0, tx:0, ty:0 });
          }catch(e){
            console.warn("Load failed", e);
          }
        }, []);

        useEffect(() => { loadState(); }, []);
        useEffect(() => {
          const id = setInterval(() => saveState("auto"), 5*60*1000);
          return () => clearInterval(id);
        }, [saveState]);

        // Selection helpers
        const selectEntity = (type, id) => {
          setSelected({ type, id });
          if(isMobile) setMobilePanelOpen(true);
        };

        const selectedEntity = useMemo(() => {
          const { type, id } = selected;
          if(!type || !id) return null;
          if(type === "room") return rooms.find(r => r.id === id) || null;
          if(type === "elev") return elevPts.find(p => p.id === id) || null;
          if(type === "note") return notes.find(n => n.id === id) || null;
          if(type === "fixture") return fixtures.find(f => f.id === id) || null;
          if(type === "opening") return openings.find(o => o.id === id) || null;
          if(type === "measure") return measurements.find(m => m.id === id) || null;
          return null;
        }, [selected, rooms, elevPts, notes, fixtures, openings, measurements]);

        const updateSelected = (patch) => {
          const { type, id } = selected;
          if(!type || !id) return;
          if(type === "room"){
            setRooms(prev => prev.map(r => {
              if(r.id !== id) return r;
              const next = { ...r, ...patch };
              return clampRoomToBoundary(next);
            }));
          }
          if(type === "elev"){
            setElevPts(prev => prev.map(p => p.id === id ? { ...p, ...patch } : p));
          }
          if(type === "note"){
            setNotes(prev => prev.map(n => n.id === id ? { ...n, ...patch } : n));
          }
          if(type === "fixture"){
            setFixtures(prev => prev.map(f => f.id === id ? { ...f, ...patch } : f));
          }
          if(type === "opening"){
            setOpenings(prev => prev.map(o => o.id === id ? { ...o, ...patch } : o));
          }
        };

        const deleteSelected = () => {
          const { type, id } = selected;
          if(!type || !id) return;
          if(type === "room") setRooms(prev => prev.filter(r => r.id !== id));
          if(type === "elev") setElevPts(prev => prev.filter(p => p.id !== id));
          if(type === "note") setNotes(prev => prev.filter(n => n.id !== id));
          if(type === "fixture") setFixtures(prev => prev.filter(f => f.id !== id));
          if(type === "opening") setOpenings(prev => prev.filter(o => o.id !== id));
          if(type === "measure") setMeasurements(prev => prev.filter(m => m.id !== id));
          setSelected({ type:null, id:null });
        };

        const distanceToSegment = (p, a, b) => {
          const vx = b.x - a.x;
          const vy = b.y - a.y;
          const wx = p.x - a.x;
          const wy = p.y - a.y;
          const c1 = vx * wx + vy * wy;
          if(c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
          const c2 = vx * vx + vy * vy;
          if(c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
          const t = c1 / c2;
          const proj = { x: a.x + t * vx, y: a.y + t * vy };
          return Math.hypot(p.x - proj.x, p.y - proj.y);
        };

        const nextSpaceName = (kind) => {
          const labelMap = {
            room: "Room",
            boundary: "Boundary",
            hallway: "Hallway",
            partial: "Partial"
          };
          const count = rooms.filter(r => r.kind === kind).length + 1;
          return `${labelMap[kind] || "Space"} ${count}`;
        };

        // Pointer handling on viewport
        const onPointerDown = (e) => {
          // Track pointers for pinch
          pointersRef.current.set(e.pointerId, { x:e.clientX, y:e.clientY });
          if(pointersRef.current.size === 2){
            startPinchIfTwo();
          }

          // If pinch is active, don't start drawing
          if(pointersRef.current.size >= 2) return;

          e.preventDefault();
          const world = screenToWorld(e.clientX, e.clientY);
          const sheet = worldToSheetPx(world.x, world.y);

          // Right now: tool can override
          if(tool === "pan"){
            setDrag({ mode:"pan", start:{ x:e.clientX, y:e.clientY }, origin:{ tx:view.tx, ty:view.ty } });
            try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
            return;
          }

          // Click outside sheet: pan
          if(!withinSheet(sheet.x, sheet.y)){
            setDrag({ mode:"pan", start:{ x:e.clientX, y:e.clientY }, origin:{ tx:view.tx, ty:view.ty } });
            try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
            return;
          }

          // If selecting, attempt hit test first
          if(tool === "select"){
            // hit test order: note -> elev -> fixture -> opening -> measure -> room
            const hitNote = [...notes].reverse().find(n => {
              const dx = n.x - sheet.x, dy = n.y - sheet.y;
              return Math.hypot(dx,dy) <= 22;
            });
            if(hitNote){
              selectEntity("note", hitNote.id);
              setDrag({ mode:"move", entity:{ type:"note", id:hitNote.id }, start:{x:e.clientX,y:e.clientY}, startWorld:world });
              try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
              return;
            }

            const hitElev = [...elevPts].reverse().find(p => {
              const dx = p.x - sheet.x, dy = p.y - sheet.y;
              return Math.hypot(dx,dy) <= 18;
            });
            if(hitElev){
              selectEntity("elev", hitElev.id);
              if(!hitElev.locked){
                setDrag({ mode:"move", entity:{ type:"elev", id:hitElev.id }, start:{x:e.clientX,y:e.clientY}, startWorld:world });
                try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
              }
              return;
            }

            const hitFixture = [...fixtures].reverse().find(f => {
              const left = f.x - f.w/2, right = f.x + f.w/2;
              const top = f.y - f.h/2, bottom = f.y + f.h/2;
              return sheet.x >= left && sheet.x <= right && sheet.y >= top && sheet.y <= bottom;
            });
            if(hitFixture){
              selectEntity("fixture", hitFixture.id);
              if(!hitFixture.locked){
                setDrag({ mode:"move", entity:{ type:"fixture", id:hitFixture.id }, start:{x:e.clientX,y:e.clientY}, startWorld:world });
                try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
              }
              return;
            }

            const hitOpening = [...openings].reverse().find(o => {
              const left = o.x - o.w/2, right = o.x + o.w/2;
              const top = o.y - o.h/2, bottom = o.y + o.h/2;
              return sheet.x >= left && sheet.x <= right && sheet.y >= top && sheet.y <= bottom;
            });
            if(hitOpening){
              selectEntity("opening", hitOpening.id);
              if(!hitOpening.locked){
                setDrag({ mode:"move", entity:{ type:"opening", id:hitOpening.id }, start:{x:e.clientX,y:e.clientY}, startWorld:world });
                try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
              }
              return;
            }

            const hitMeasure = [...measurements].reverse().find(m => {
              return distanceToSegment(sheet, { x: m.x1, y: m.y1 }, { x: m.x2, y: m.y2 }) <= 10;
            });
            if(hitMeasure){
              selectEntity("measure", hitMeasure.id);
              return;
            }

            const hitRoom = [...rooms].reverse().find(r => {
              const left = r.cx - r.w/2, right = r.cx + r.w/2;
              const top = r.cy - r.h/2, bottom = r.cy + r.h/2;
              return sheet.x >= left && sheet.x <= right && sheet.y >= top && sheet.y <= bottom;
            });
            if(hitRoom){
              selectEntity("room", hitRoom.id);
              if(!hitRoom.locked){
                setDrag({ mode:"move", entity:{ type:"room", id:hitRoom.id }, start:{x:e.clientX,y:e.clientY}, startWorld:world });
                try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
              }
              return;
            }

            // empty click clears selection
            setSelected({ type:null, id:null });
            return;
          }

          if(tool === "draw"){
            if(drawType !== "boundary" && boundaryRect && !isPointInsideBoundary(sheet.x, sheet.y)){
              return;
            }
            // start rect draw
            const start = sheet;
            const newId = uid();
            const newRoom = {
              id:newId,
              cx:start.x,
              cy:start.y,
              w:10,
              h:10,
              name: nextSpaceName(drawType),
              kind: drawType,
              locked: false,
              caption: "",
              notes: "",
              photo: ""
            };
            setRooms(prev => {
              if(drawType === "boundary"){
                return [...prev.filter(r => r.kind !== "boundary"), newRoom];
              }
              return [...prev, newRoom];
            });
            selectEntity("room", newId);
            setDrag({ mode:"room-draw", id:newId, rectStartWorld: world });
            try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
            return;
          }

          if(tool === "elev"){
            const val = Number(draftElevation.reading);
            if(!Number.isFinite(val)) return;
            if(boundaryRect && !isPointInsideBoundary(sheet.x, sheet.y)){
              return;
            }
            const id = uid();
            setElevPts(prev => [...prev, { id, x:sheet.x, y:sheet.y, reading: val, note: draftElevation.note || "", caption: "", photo: "", locked: false }]);
            selectEntity("elev", id);
            return;
          }

          if(tool === "observation"){
            const id = uid();
            setNotes(prev => [...prev, {
              id,
              x:sheet.x,
              y:sheet.y,
              category: draftObservation.category || "Observation",
              text: draftObservation.text || "Observation",
              caption: draftObservation.caption || "",
              photo: draftObservation.photo || ""
            }]);
            selectEntity("note", id);
            return;
          }

          if(tool === "fixture"){
            const id = uid();
            setFixtures(prev => [...prev, {
              id,
              x: sheet.x,
              y: sheet.y,
              w: Number(draftFixture.w) || 40,
              h: Number(draftFixture.h) || 40,
              kind: draftFixture.kind,
              label: draftFixture.label || draftFixture.kind,
              locked: false
            }]);
            selectEntity("fixture", id);
            return;
          }

          if(tool === "opening"){
            const id = uid();
            setOpenings(prev => [...prev, {
              id,
              x: sheet.x,
              y: sheet.y,
              w: Number(draftOpening.w) || 44,
              h: Number(draftOpening.h) || 14,
              kind: draftOpening.kind,
              label: draftOpening.label || draftOpening.kind,
              locked: false
            }]);
            selectEntity("opening", id);
            return;
          }

          if(tool === "measure"){
            if(!measureDraft){
              setMeasureDraft({ x1: sheet.x, y1: sheet.y, x2: sheet.x, y2: sheet.y });
              return;
            }
            const id = uid();
            setMeasurements(prev => [...prev, { id, x1: measureDraft.x1, y1: measureDraft.y1, x2: sheet.x, y2: sheet.y }]);
            setMeasureDraft(null);
            selectEntity("measure", id);
            return;
          }
        };

        const onPointerMove = (e) => {
          // pinch update
          if(pointersRef.current.has(e.pointerId)){
            pointersRef.current.set(e.pointerId, { x:e.clientX, y:e.clientY });
            if(pointersRef.current.size === 2){
              updatePinch();
              return;
            }
          }

          if(tool === "measure" && measureDraft){
            const world = screenToWorld(e.clientX, e.clientY);
            const sheet = worldToSheetPx(world.x, world.y);
            setMeasureDraft(prev => prev ? ({ ...prev, x2: sheet.x, y2: sheet.y }) : prev);
          }

          if(!drag) return;
          e.preventDefault();

          if(drag.mode === "pan"){
            const dx = e.clientX - drag.start.x;
            const dy = e.clientY - drag.start.y;
            setView(prev => ({ ...prev, tx: drag.origin.tx + dx, ty: drag.origin.ty + dy }));
            return;
          }

          if(drag.mode === "room-draw"){
            const world = screenToWorld(e.clientX, e.clientY);
            const sheet = worldToSheetPx(world.x, world.y);
            const startWorld = drag.rectStartWorld;
            const startSheet = worldToSheetPx(startWorld.x, startWorld.y);

            const id = drag.id;
            let left = Math.min(startSheet.x, sheet.x);
            let right = Math.max(startSheet.x, sheet.x);
            let top = Math.min(startSheet.y, sheet.y);
            let bottom = Math.max(startSheet.y, sheet.y);
            if(boundaryRect && drawType !== "boundary"){
              left = clamp(left, boundaryRect.left, boundaryRect.right);
              right = clamp(right, boundaryRect.left, boundaryRect.right);
              top = clamp(top, boundaryRect.top, boundaryRect.bottom);
              bottom = clamp(bottom, boundaryRect.top, boundaryRect.bottom);
            }

            const cx = (left+right)/2;
            const cy = (top+bottom)/2;
            const w = Math.max(24, right-left);
            const h = Math.max(24, bottom-top);

            setRooms(prev => prev.map(r => r.id === id ? { ...r, cx, cy, w, h } : r));
            return;
          }

          if(drag.mode === "move"){
            const world = screenToWorld(e.clientX, e.clientY);
            const deltaWorld = { x: world.x - drag.startWorld.x, y: world.y - drag.startWorld.y };
            const deltaSheet = { x: deltaWorld.x, y: deltaWorld.y }; // since world is sheet-centered in px units
            const { type, id } = drag.entity;

            if(type === "room"){
              setRooms(prev => prev.map(r => {
                if(r.id !== id) return r;
                const moved = { ...r, cx: r.cx + deltaSheet.x, cy: r.cy + deltaSheet.y };
                return clampRoomToBoundary(moved);
              }));
            }
            if(type === "elev"){
              setElevPts(prev => prev.map(p => {
                if(p.id !== id) return p;
                const next = { ...p, x: p.x + deltaSheet.x, y: p.y + deltaSheet.y };
                if(boundaryRect){
                  return {
                    ...next,
                    x: clamp(next.x, boundaryRect.left, boundaryRect.right),
                    y: clamp(next.y, boundaryRect.top, boundaryRect.bottom)
                  };
                }
                return next;
              }));
            }
            if(type === "note"){
              setNotes(prev => prev.map(n => n.id === id ? { ...n, x: n.x + deltaSheet.x, y: n.y + deltaSheet.y } : n));
            }
            if(type === "fixture"){
              setFixtures(prev => prev.map(f => f.id === id ? { ...f, x: f.x + deltaSheet.x, y: f.y + deltaSheet.y } : f));
            }
            if(type === "opening"){
              setOpenings(prev => prev.map(o => o.id === id ? { ...o, x: o.x + deltaSheet.x, y: o.y + deltaSheet.y } : o));
            }

            // update baseline for smooth drag
            setDrag(prev => prev ? ({ ...prev, startWorld: world }) : prev);
            return;
          }

          if(drag.mode === "resize-room"){
            const world = screenToWorld(e.clientX, e.clientY);
            const sheet = worldToSheetPx(world.x, world.y);
            const { id, handle, startSheet, startRoom } = drag;
            let left = startRoom.cx - startRoom.w/2;
            let right = startRoom.cx + startRoom.w/2;
            let top = startRoom.cy - startRoom.h/2;
            let bottom = startRoom.cy + startRoom.h/2;

            const dx = sheet.x - startSheet.x;
            const dy = sheet.y - startSheet.y;

            if(handle.includes("r")) right += dx;
            if(handle.includes("l")) left += dx;
            if(handle.includes("b")) bottom += dy;
            if(handle.includes("t")) top += dy;

            const minSize = 24;
            if(right - left < minSize){
              if(handle.includes("l")) left = right - minSize;
              else right = left + minSize;
            }
            if(bottom - top < minSize){
              if(handle.includes("t")) top = bottom - minSize;
              else bottom = top + minSize;
            }

            if(boundaryRect && startRoom.kind !== "boundary"){
              left = clamp(left, boundaryRect.left, boundaryRect.right - minSize);
              right = clamp(right, boundaryRect.left + minSize, boundaryRect.right);
              top = clamp(top, boundaryRect.top, boundaryRect.bottom - minSize);
              bottom = clamp(bottom, boundaryRect.top + minSize, boundaryRect.bottom);
            }

            const cx = (left + right) / 2;
            const cy = (top + bottom) / 2;
            const w = Math.max(minSize, right - left);
            const h = Math.max(minSize, bottom - top);

            setRooms(prev => prev.map(r => r.id === id ? { ...r, cx, cy, w, h } : r));
            return;
          }
        };

        const onPointerUp = (e) => {
          // remove pointer
          pointersRef.current.delete(e.pointerId);
          if(pointersRef.current.size < 2){
            pinchRef.current = null;
          }
          if(drag){
            setDrag(null);
            try { e.currentTarget.releasePointerCapture(e.pointerId); } catch {}
          }
        };

        // Export/Import
        const exportJson = () => {
          const s = buildState();
          downloadText(`TitanFoundation_${projectName.replace(/\s+/g,"_") || "Project"}.json`, JSON.stringify(s, null, 2));
        };

        const importJson = async (file) => {
          if(!file) return;
          try{
            const text = await file.text();
            const s = JSON.parse(text);

            setProjectName(s.projectName ?? "Enter Name");
            setFrontFaces(s.frontFaces ?? "North");
            setScaleFtPerMajor(Number.isFinite(s.scaleFtPerMajor) ? s.scaleFtPerMajor : 5);
            setLeak(s.leak ?? leak);
            setRooms(Array.isArray(s.rooms) ? s.rooms : []);
            setElevPts(Array.isArray(s.elevPts) ? s.elevPts : []);
            setNotes(Array.isArray(s.notes) ? s.notes : []);
            setFixtures(Array.isArray(s.fixtures) ? s.fixtures : []);
            setOpenings(Array.isArray(s.openings) ? s.openings : []);
            setMeasurements(Array.isArray(s.measurements) ? s.measurements : []);
            setDrawType(s.drawType ?? "room");
            setView(s.view ?? { scale:1.0, tx:0, ty:0 });

            setSelected({ type:null, id:null });
            if(isMobile) setMobilePanelOpen(true);
          }catch(err){
            alert("Import failed. Please verify it is a TitanFoundation JSON export.");
          }
        };

        // Derived room dimensions (approx) using scaleFtPerMajor; major grid is 50px
        const pxPerMajor = 50;
        const formatFeetInches = (feetValue) => {
          const sign = feetValue < 0 ? "-" : "";
          const totalInches = Math.abs(feetValue) * 12;
          const rounded = Math.round(totalInches * 8) / 8;
          let feet = Math.floor(rounded / 12);
          let inches = rounded - feet * 12;
          let whole = Math.floor(inches);
          let frac = inches - whole;
          if(whole >= 12){
            feet += Math.floor(whole / 12);
            whole = whole % 12;
          }
          const gcd = (a,b) => b ? gcd(b, a % b) : a;
          let fracText = "";
          if(frac > 0.001){
            const denom = 8;
            let num = Math.round(frac * denom);
            if(num === denom){
              whole += 1;
              num = 0;
            }
            if(whole >= 12){
              feet += 1;
              whole = 0;
            }
            if(num > 0){
              const g = gcd(num, denom);
              fracText = ` ${num/g}/${denom/g}`;
            }
          }
          return `${sign}${feet}' ${whole}${fracText}"`;
        };

        const roomDimsText = (room) => {
          const ftPerPx = scaleFtPerMajor / pxPerMajor;
          const wFt = room.w * ftPerPx;
          const hFt = room.h * ftPerPx;
          return `${formatFeetInches(wFt)}  ${formatFeetInches(hFt)}`;
        };

        const pxToFt = (px) => (scaleFtPerMajor / pxPerMajor) * px;
        const ftToPx = (ft) => (pxPerMajor / scaleFtPerMajor) * ft;
        const splitFeetInches = (feetValue) => {
          const totalInches = Math.round(feetValue * 12 * 8) / 8;
          const feet = Math.floor(totalInches / 12);
          const inches = Math.max(0, totalInches - feet * 12);
          return { feet, inches };
        };
        const measurementText = (m) => {
          const dist = Math.hypot(m.x2 - m.x1, m.y2 - m.y1);
          return formatFeetInches(pxToFt(dist));
        };

        const selectedRoomDimParts = useMemo(() => {
          if(selected.type !== "room") return null;
          if(!selectedEntity) return null;
          return {
            w: splitFeetInches(pxToFt(selectedEntity.w)),
            h: splitFeetInches(pxToFt(selectedEntity.h))
          };
        }, [selected.type, selectedEntity, scaleFtPerMajor]);

        // Render
        const panelClass = [
          "panel",
          panelCollapsed ? "panelCollapsed" : "",
          (isMobile && mobilePanelOpen) ? "mobileOpen" : ""
        ].join(" ").trim();

        return (
          <>
            {isMobile && (
              <div
                className={"panelOverlay " + (mobilePanelOpen ? "show" : "")}
                onClick={() => setMobilePanelOpen(false)}
              />
            )}

            <div
              className={`toolbar ${toolbarCollapsed ? "collapsed" : ""} ${drag?.mode === "toolbar-drag" ? "dragging" : ""}`}
              style={{ left: toolbarPos.x, top: toolbarPos.y }}
            >
              <div
                className={`toolbarHandle ${toolbarLocked ? "locked" : ""}`}
                title={toolbarLocked ? "Toolbar locked" : "Drag toolbar"}
                onPointerDown={(e) => {
                  if(toolbarLocked) return;
                  e.stopPropagation();
                  setDrag({
                    mode: "toolbar-drag",
                    start: { x: e.clientX, y: e.clientY },
                    origin: { x: toolbarPos.x, y: toolbarPos.y }
                  });
                  try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
                }}
              >
                
              </div>
              <button className={"toolBtn " + (tool==="select" ? "active" : "")} onClick={() => setTool("select")}>
                {toolbarCollapsed ? "Sel" : "Select"}
              </button>
              <button className={"toolBtn " + (tool==="pan" ? "active" : "")} onClick={() => setTool("pan")}>
                {toolbarCollapsed ? "Pan" : "Pan"}
              </button>
              <span className="tbDivider"></span>
              <button className={"toolBtn room " + (tool==="draw" ? "active" : "")} onClick={() => setTool("draw")}>
                {toolbarCollapsed ? "Draw" : "Draw"}
              </button>
              <button className={"toolBtn elev " + (tool==="elev" ? "active" : "")} onClick={() => setTool("elev")}>
                {toolbarCollapsed ? "Elev" : "Elevation"}
              </button>
              <button className={"toolBtn note " + (tool==="observation" ? "active" : "")} onClick={() => setTool("observation")}>
                {toolbarCollapsed ? "Obs" : "Observation"}
              </button>
              <button className={"toolBtn item " + ((tool==="fixture" || tool==="opening") ? "active" : "")} onClick={() => setTool("fixture")}>
                {toolbarCollapsed ? "Items" : "Items"}
              </button>
              <button className="toolBtn" onClick={() => setToolbarLocked(v => !v)} title={toolbarLocked ? "Unlock toolbar" : "Lock toolbar"}>
                {toolbarLocked ? "" : ""}
              </button>
              <button className="toolBtn" onClick={() => setToolbarCollapsed(v => !v)} title="Collapse toolbar">
                {toolbarCollapsed ? "" : ""}
              </button>
              {isMobile && (
                <>
                  <span className="tbDivider"></span>
                  <button className="toolBtn" onClick={() => setMobilePanelOpen(true)}>Panel</button>
                </>
              )}
              {tool === "draw" && (
                <div className="toolbarMenu">
                  <div className="menuRow">
                    {[
                      ["boundary","Boundary"],
                      ["room","Room"],
                      ["hallway","Hallway"],
                      ["partial","Partial/Offset"]
                    ].map(([value,label]) => (
                      <button
                        key={value}
                        className={`menuBtn ${drawType === value ? "active" : ""}`}
                        onClick={() => setDrawType(value)}
                      >
                        {label}
                      </button>
                    ))}
                  </div>
                  <div className="tiny">Draw within boundary. Boundary is required before adding rooms or elevations.</div>
                </div>
              )}
              {(tool === "fixture" || tool === "opening") && (
                <div className="toolbarMenu">
                  <div className="menuRow">
                    <button className={`menuBtn ${tool === "fixture" ? "active" : ""}`} onClick={() => setTool("fixture")}>Fixture</button>
                    <button className={`menuBtn ${tool === "opening" ? "active" : ""}`} onClick={() => setTool("opening")}>Opening</button>
                  </div>
                  <div className="tiny">Place fixtures or openings inside rooms without dimensions.</div>
                </div>
              )}
            </div>

            <div className="app">
              <div className="canvasZone" onWheel={onWheel}>
                <div
                  className="viewport"
                  ref={viewportRef}
                  onPointerDown={onPointerDown}
                  onPointerMove={onPointerMove}
                  onPointerUp={onPointerUp}
                  onPointerCancel={onPointerUp}
                >
                  <div
                    className="stage"
                    style={{
                      transform: `translate(${view.tx}px, ${view.ty}px) scale(${view.scale}) translate(${-SHEET.w/2}px, ${-SHEET.h/2}px)`
                    }}
                  >
                    <div className="sheet" style={{ "--sheet-width": `${SHEET.w}px`, "--sheet-height": `${SHEET.h}px` }}>
                      {/* Grid */}
                      <svg className="gridSvg" width={SHEET.w} height={SHEET.h}>
                        {Array.from({length: Math.floor(SHEET.w/10)+1}).map((_,i) => {
                          const x = i*10;
                          const isMajor = x % 50 === 0;
                          return <line key={"vx"+i} x1={x} y1={0} x2={x} y2={SHEET.h} className={isMajor ? "major":"minor"} />;
                        })}
                        {Array.from({length: Math.floor(SHEET.h/10)+1}).map((_,i) => {
                          const y = i*10;
                          const isMajor = y % 50 === 0;
                          return <line key={"hy"+i} x1={0} y1={y} x2={SHEET.w} y2={y} className={isMajor ? "major":"minor"} />;
                        })}
                      </svg>

                      {showHeatmap && elevPts.length > 1 && (
                        <svg className="heatSvg" width={SHEET.w} height={SHEET.h}>
                          <defs>
                            <filter id="heatBlur">
                              <feGaussianBlur stdDeviation="18" />
                            </filter>
                          </defs>
                          {elevPts.map(p => {
                            const color = elevColor(Number(p.reading));
                            return (
                              <circle
                                key={`heat-${p.id}`}
                                cx={p.x}
                                cy={p.y}
                                r={80}
                                fill={color}
                                opacity={0.22}
                                filter="url(#heatBlur)"
                              />
                            );
                          })}
                        </svg>
                      )}

                      <svg className="measureSvg" width={SHEET.w} height={SHEET.h}>
                        {measurements.map(m => (
                          <g key={m.id} onPointerDown={(e) => {
                            if(tool !== "select") return;
                            e.stopPropagation();
                            selectEntity("measure", m.id);
                          }}>
                            <line x1={m.x1} y1={m.y1} x2={m.x2} y2={m.y2} className="measureLine" />
                            <text
                              x={(m.x1 + m.x2) / 2}
                              y={(m.y1 + m.y2) / 2 - 6}
                              className="measureLabel"
                            >
                              {measurementText(m)}
                            </text>
                          </g>
                        ))}
                        {measureDraft && tool === "measure" && (
                          <g>
                            <line x1={measureDraft.x1} y1={measureDraft.y1} x2={measureDraft.x2} y2={measureDraft.y2} className="measureLine draft" />
                          </g>
                        )}
                      </svg>

                      {/* Spaces */}
                      {rooms.map(r => (
                        <div
                          key={r.id}
                          className={`spaceRect ${r.kind || "room"} ${r.locked ? "locked" : ""}`}
                          onPointerDown={(e) => {
                            if(tool !== "select") return;
                            e.stopPropagation();
                            selectEntity("room", r.id);
                          }}
                          style={{
                            left: r.cx,
                            top: r.cy,
                            width: r.w,
                            height: r.h
                          }}
                        >
                          <div className="roomLabel">
                            <span className="roomName">{r.name}</span>
                            <span className="roomMeta">{roomDimsText(r)}</span>
                            <span className="roomKind">{(r.kind || "room").toUpperCase()}</span>
                            {r.locked && <span className="roomKind">LOCKED</span>}
                          </div>
                          {selected.type === "room" && selected.id === r.id && !r.locked && tool === "select" && (
                            <>
                              {["tl","tr","bl","br"].map(handle => (
                                <div
                                  key={handle}
                                  className={`roomHandle ${handle}`}
                                  onPointerDown={(e) => {
                                    e.stopPropagation();
                                    const world = screenToWorld(e.clientX, e.clientY);
                                    const sheet = worldToSheetPx(world.x, world.y);
                                    setDrag({
                                      mode: "resize-room",
                                      id: r.id,
                                      handle,
                                      startSheet: sheet,
                                      startRoom: r
                                    });
                                    try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
                                  }}
                                />
                              ))}
                            </>
                          )}
                        </div>
                      ))}

                      {/* Openings */}
                      {openings.map(o => (
                        <div
                          key={o.id}
                          className={`openingRect ${o.kind || ""} ${o.locked ? "locked" : ""}`}
                          onPointerDown={(e) => {
                            if(tool !== "select") return;
                            e.stopPropagation();
                            selectEntity("opening", o.id);
                          }}
                          style={{
                            left: o.x,
                            top: o.y,
                            width: o.w,
                            height: o.h
                          }}
                        >
                          <div className="fixtureLabel">{o.label}</div>
                        </div>
                      ))}

                      {/* Fixtures */}
                      {fixtures.map(f => (
                        <div
                          key={f.id}
                          className={`fixtureRect ${f.kind || ""} ${f.locked ? "locked" : ""}`}
                          onPointerDown={(e) => {
                            if(tool !== "select") return;
                            e.stopPropagation();
                            selectEntity("fixture", f.id);
                          }}
                          style={{
                            left: f.x,
                            top: f.y,
                            width: f.w,
                            height: f.h
                          }}
                        >
                          <div className="fixtureLabel">{f.label}</div>
                        </div>
                      ))}

                      {/* Elevation points */}
                      {elevPts.map(p => {
                        const value = Number(p.reading);
                        const cls = classifyElev(value);
                        const color = elevColor(value);
                        const delta = value - zeroRef;
                        const deltaText = `${delta >= 0 ? "+" : "-"}${formatFeetInches(Math.abs(delta))}`;
                        return (
                          <div key={p.id} style={{ position:"absolute", left:p.x, top:p.y }}>
                            <div
                              className="elevBadge"
                              onPointerDown={(e) => {
                                if(tool !== "select") return;
                                e.stopPropagation();
                                selectEntity("elev", p.id);
                              }}
                              style={{ left:0, top:0 }}
                            >
                              {formatFeetInches(Number.isFinite(value) ? value : 0)} <small>{cls.tag}</small>
                              <small> {deltaText}</small>
                            </div>
                            <div
                              className="elevDot"
                              onPointerDown={(e) => {
                                if(tool !== "select") return;
                                e.stopPropagation();
                                selectEntity("elev", p.id);
                              }}
                              style={{ left:0, top:22, background: color }}
                            />
                          </div>
                        );
                      })}

                      {/* Observations */}
                      {notes.map(n => (
                        <div
                          key={n.id}
                          className="noteMarker"
                          title={n.text}
                          onPointerDown={(e) => {
                            if(tool !== "select") return;
                            e.stopPropagation();
                            selectEntity("note", n.id);
                          }}
                          style={{ left:n.x, top:n.y }}
                        >
                          O
                        </div>
                      ))}
                    </div>
                  </div>
                </div>

                <div className="navTools">
                  <div className="navCard">
                    <div className="navRow">
                      <div className="zBtns">
                        <button className="zBtn" onClick={zoomOut}></button>
                        <button className="zBtn" onClick={zoomIn}>+</button>
                        <button className="zBtn" onClick={zoomReset}>Reset</button>
                      </div>
                      <div className="zReadout">{Math.round(view.scale*100)}%</div>
                    </div>
                    <div className="hint">
                      Tip: Use two fingers to pan/zoom on iPad. Use Select to move spaces, fixtures, and points. Lock items when finalized.
                    </div>
                  </div>
                </div>
              </div>

              <div className={panelClass}>
                <div className="pHeader">
                  <div className="titleWrap" style={{ minWidth:0 }}>
                    <div className="small">TitanFoundation</div>
                    <div className="big" title={projectName}>{projectName}</div>
                    <div className="small" style={{ textTransform:"none", opacity:0.8 }}>{frontFaces}</div>
                  </div>
                  <div className="pHeaderActions">
                    <button className="headerBtn" onClick={() => saveState("manual")} title="Save"></button>
                    <button className="headerBtn" onClick={exportJson} title="Export"></button>
                    <button className="headerBtn" onClick={zoomFit} title="Fit view"></button>
                    <button className="headerBtn" onClick={() => setPanelExpanded(v => !v)} title="Project settings">
                      {panelExpanded ? "" : ""}
                    </button>
                    <button className="collapseBtn" onClick={() => setPanelCollapsed(v => !v)} title="Collapse/Expand">
                      {panelCollapsed ? "" : ""}
                    </button>
                  </div>
                </div>

                <div className="pScroll">
                  {panelExpanded && (
                    <div className="card" style={{ background:"#0B2A3A", color:"#fff", borderColor:"rgba(255,255,255,0.18)" }}>
                      <div className="lbl" style={{ color:"rgba(255,255,255,0.75)" }}>Project &amp; scale</div>
                      <div>
                        <label className="lbl" style={{ color:"rgba(255,255,255,0.75)" }}>Project</label>
                        <input className="inp" value={projectName} onChange={(e)=>setProjectName(e.target.value)} placeholder="Enter Name" />
                      </div>
                      <div className="row" style={{ marginTop:10 }}>
                        <div>
                          <label className="lbl" style={{ color:"rgba(255,255,255,0.75)" }}>Front faces</label>
                          <select value={frontFaces} onChange={(e)=>setFrontFaces(e.target.value)}>
                            {["North","South","East","West","Northeast","Northwest","Southeast","Southwest"].map(v => (
                              <option key={v} value={v}>{v}</option>
                            ))}
                          </select>
                        </div>
                        <div>
                          <label className="lbl" style={{ color:"rgba(255,255,255,0.75)" }}>Scale</label>
                          <select value={scaleFtPerMajor} onChange={(e)=>setScaleFtPerMajor(Number(e.target.value))}>
                            {[2,5,10,15,20].map(v => (
                              <option key={v} value={v}>{v} ft / major grid</option>
                            ))}
                          </select>
                        </div>
                      </div>
                      <div className="row" style={{ marginTop:10 }}>
                        <button className="btn btnPrimary" onClick={() => saveState("manual")}>Save</button>
                        <button className="btn" onClick={loadState}>Load</button>
                      </div>
                      <div className="row" style={{ marginTop:10 }}>
                        <label className="btn" style={{ margin:0 }}>
                          Import JSON
                          <input type="file" accept="application/json" style={{ display:"none" }}
                            onChange={(e)=>importJson(e.target.files?.[0])}
                          />
                        </label>
                        <button className="btn" onClick={exportJson}>Export JSON</button>
                      </div>
                    </div>
                  )}

                  {selectedEntity ? (
                    <div className="card">
                      <div className="row" style={{ justifyContent:"space-between", marginBottom:8 }}>
                        <div className="pill">Selected {selected.type}</div>
                        <button className="btn" onClick={() => { setSelected({ type:null, id:null }); setTool("select"); }}>Back</button>
                      </div>

                      {selected.type === "room" && (
                        <>
                          <label className="lbl">Name</label>
                          <input className="inp" value={selectedEntity.name} onChange={(e)=>updateSelected({ name:e.target.value })} />
                          <label className="lbl" style={{ marginTop:8 }}>Kind</label>
                          <select value={selectedEntity.kind || "room"} onChange={(e)=>updateSelected({ kind:e.target.value })}>
                            {["room","boundary","hallway","partial"].map(v => (
                              <option key={v} value={v}>{v}</option>
                            ))}
                          </select>
                          {selectedRoomDimParts && (
                            <>
                              <label className="lbl" style={{ marginTop:8 }}>Dimensions</label>
                              <div className="row">
                                <div>
                                  <label className="lbl">Width (ft/in)</label>
                                  <div className="row">
                                    <input
                                      className="inp"
                                      type="number"
                                      value={selectedRoomDimParts.w.feet}
                                      onChange={(e)=>{
                                        const feet = Number(e.target.value) || 0;
                                        const totalFt = Math.max(0.1, feet + (selectedRoomDimParts.w.inches / 12));
                                        updateSelected({ w: ftToPx(totalFt) });
                                      }}
                                    />
                                    <input
                                      className="inp"
                                      type="number"
                                      step="0.125"
                                      value={selectedRoomDimParts.w.inches}
                                      onChange={(e)=>{
                                        const inches = Number(e.target.value) || 0;
                                        const totalFt = Math.max(0.1, selectedRoomDimParts.w.feet + (inches / 12));
                                        updateSelected({ w: ftToPx(totalFt) });
                                      }}
                                    />
                                  </div>
                                </div>
                                <div>
                                  <label className="lbl">Height (ft/in)</label>
                                  <div className="row">
                                    <input
                                      className="inp"
                                      type="number"
                                      value={selectedRoomDimParts.h.feet}
                                      onChange={(e)=>{
                                        const feet = Number(e.target.value) || 0;
                                        const totalFt = Math.max(0.1, feet + (selectedRoomDimParts.h.inches / 12));
                                        updateSelected({ h: ftToPx(totalFt) });
                                      }}
                                    />
                                    <input
                                      className="inp"
                                      type="number"
                                      step="0.125"
                                      value={selectedRoomDimParts.h.inches}
                                      onChange={(e)=>{
                                        const inches = Number(e.target.value) || 0;
                                        const totalFt = Math.max(0.1, selectedRoomDimParts.h.feet + (inches / 12));
                                        updateSelected({ h: ftToPx(totalFt) });
                                      }}
                                    />
                                  </div>
                                </div>
                              </div>
                            </>
                          )}
                          <label className="lbl" style={{ marginTop:8 }}>Caption</label>
                          <input className="inp" value={selectedEntity.caption || ""} onChange={(e)=>updateSelected({ caption:e.target.value })} placeholder="Room caption" />
                          <label className="lbl" style={{ marginTop:8 }}>Notes</label>
                          <textarea value={selectedEntity.notes || ""} onChange={(e)=>updateSelected({ notes:e.target.value })} />
                          <label className="lbl" style={{ marginTop:8 }}>Photo URL</label>
                          <input className="inp" value={selectedEntity.photo || ""} onChange={(e)=>updateSelected({ photo:e.target.value })} placeholder="Paste image link" />
                          <label style={{ display:"flex", gap:10, alignItems:"center", fontSize:13, fontWeight:1000, marginTop:8 }}>
                            <input type="checkbox" checked={!!selectedEntity.locked} onChange={(e)=>updateSelected({ locked:e.target.checked })} />
                            Lock movement
                          </label>
                        </>
                      )}

                      {selected.type === "elev" && (
                        <>
                          <label className="lbl">Elevation reading</label>
                          <input
                            className="inp"
                            value={selectedEntity.reading}
                            onChange={(e)=>{
                              const v = Number(e.target.value);
                              updateSelected({ reading: Number.isFinite(v) ? v : selectedEntity.reading });
                            }}
                          />
                          <label className="lbl" style={{ marginTop:10 }}>Note</label>
                          <textarea value={selectedEntity.note || ""} onChange={(e)=>updateSelected({ note:e.target.value })} />
                          <label className="lbl" style={{ marginTop:10 }}>Caption</label>
                          <input className="inp" value={selectedEntity.caption || ""} onChange={(e)=>updateSelected({ caption:e.target.value })} placeholder="Caption" />
                          <label className="lbl" style={{ marginTop:10 }}>Photo URL</label>
                          <input className="inp" value={selectedEntity.photo || ""} onChange={(e)=>updateSelected({ photo:e.target.value })} placeholder="Paste image link" />
                          <label style={{ display:"flex", gap:10, alignItems:"center", fontSize:13, fontWeight:1000, marginTop:8 }}>
                            <input type="checkbox" checked={!!selectedEntity.locked} onChange={(e)=>updateSelected({ locked:e.target.checked })} />
                            Lock movement
                          </label>
                        </>
                      )}

                      {selected.type === "note" && (
                        <>
                          <label className="lbl">Observation type</label>
                          <select value={selectedEntity.category || "Observation"} onChange={(e)=>updateSelected({ category:e.target.value })}>
                            {observationOptions.map(opt => (
                              <option key={opt} value={opt}>{opt}</option>
                            ))}
                          </select>
                          <label className="lbl" style={{ marginTop:8 }}>Notes</label>
                          <textarea value={selectedEntity.text || ""} onChange={(e)=>updateSelected({ text:e.target.value })} />
                          <label className="lbl" style={{ marginTop:8 }}>Caption</label>
                          <input className="inp" value={selectedEntity.caption || ""} onChange={(e)=>updateSelected({ caption:e.target.value })} placeholder="Caption" />
                          <label className="lbl" style={{ marginTop:8 }}>Photo URL</label>
                          <input className="inp" value={selectedEntity.photo || ""} onChange={(e)=>updateSelected({ photo:e.target.value })} placeholder="Paste image link" />
                        </>
                      )}

                      {selected.type === "fixture" && (
                        <>
                          <label className="lbl">Label</label>
                          <input className="inp" value={selectedEntity.label} onChange={(e)=>updateSelected({ label:e.target.value })} />
                          <label className="lbl" style={{ marginTop:8 }}>Kind</label>
                          <input className="inp" value={selectedEntity.kind} onChange={(e)=>updateSelected({ kind:e.target.value })} />
                          <label style={{ display:"flex", gap:10, alignItems:"center", fontSize:13, fontWeight:1000, marginTop:8 }}>
                            <input type="checkbox" checked={!!selectedEntity.locked} onChange={(e)=>updateSelected({ locked:e.target.checked })} />
                            Lock movement
                          </label>
                        </>
                      )}

                      {selected.type === "opening" && (
                        <>
                          <label className="lbl">Label</label>
                          <input className="inp" value={selectedEntity.label} onChange={(e)=>updateSelected({ label:e.target.value })} />
                          <label className="lbl" style={{ marginTop:8 }}>Kind</label>
                          <input className="inp" value={selectedEntity.kind} onChange={(e)=>updateSelected({ kind:e.target.value })} />
                          <label style={{ display:"flex", gap:10, alignItems:"center", fontSize:13, fontWeight:1000, marginTop:8 }}>
                            <input type="checkbox" checked={!!selectedEntity.locked} onChange={(e)=>updateSelected({ locked:e.target.checked })} />
                            Lock movement
                          </label>
                        </>
                      )}

                      {selected.type === "measure" && (
                        <div className="tiny">Measurement length: {measurementText(selectedEntity)}</div>
                      )}

                      <div className="row" style={{ marginTop:10 }}>
                        <button className="btn btnDanger" onClick={deleteSelected}>Delete</button>
                        <button className="btn" onClick={()=>setSelected({ type:null, id:null })}>Clear</button>
                      </div>
                    </div>
                  ) : (
                    <>
                      {tool === "draw" && (
                        <div className="card">
                          <label className="lbl">Draw mode</label>
                          <div className="pill" style={{ marginBottom:8 }}>{drawType}</div>
                          <div className="tiny">Rooms and elevations must stay inside the boundary. Use the toolbar menu to switch draw types.</div>
                        </div>
                      )}

                      {tool === "elev" && (
                        <div className="card" style={{ borderColor:"rgba(22,163,74,0.3)" }}>
                          <label className="lbl">Elevation reading</label>
                          <input
                            className="inp"
                            value={draftElevation.reading}
                            onChange={(e)=>setDraftElevation(prev => ({ ...prev, reading: e.target.value }))}
                          />
                          <label className="lbl" style={{ marginTop:10 }}>Note</label>
                          <input
                            className="inp"
                            value={draftElevation.note}
                            onChange={(e)=>setDraftElevation(prev => ({ ...prev, note: e.target.value }))}
                            placeholder="e.g. North wall"
                          />
                          <div className="row" style={{ marginTop:10 }}>
                            <button className={"btn " + (tool==="elev" ? "btnPrimary" : "")} onClick={() => setTool("elev")}>Use Elevation Tool</button>
                            <button className="btn" onClick={() => setShowHeatmap(v => !v)}>{showHeatmap ? "Hide Heatmap" : "Show Heatmap"}</button>
                          </div>
                          {elevSummary.min == null ? (
                            <div className="tiny" style={{ marginTop:8 }}>No elevation points yet. Place readings around the perimeter and interior.</div>
                          ) : (
                            <>
                              <div className="row" style={{ marginTop:10 }}>
                                <div className="pill">Min: {formatFeetInches(elevSummary.min)}</div>
                                <div className="pill">Max: {formatFeetInches(elevSummary.max)}</div>
                                <div className="pill">Diff: {formatFeetInches(elevSummary.diff)}</div>
                              </div>
                              <div className="row" style={{ marginTop:8 }}>
                                <label className="lbl" style={{ margin:0 }}>Zero reference</label>
                                <select value={zeroMode} onChange={(e)=>setZeroMode(e.target.value)}>
                                  <option value="auto">Auto (midpoint)</option>
                                  <option value="custom">Custom</option>
                                </select>
                              </div>
                              {zeroMode === "custom" && (
                                <input
                                  className="inp"
                                  value={customZero}
                                  onChange={(e)=>setCustomZero(e.target.value)}
                                  placeholder="Enter zero reference"
                                />
                              )}
                            </>
                          )}
                        </div>
                      )}

                      {tool === "observation" && (
                        <div className="card" style={{ borderColor:"rgba(147,51,234,0.35)" }}>
                          <label className="lbl">Observation type</label>
                          <select
                            value={draftObservation.category}
                            onChange={(e)=>setDraftObservation(prev => ({ ...prev, category: e.target.value }))}
                          >
                            {observationOptions.map(opt => (
                              <option key={opt} value={opt}>{opt}</option>
                            ))}
                          </select>
                          <label className="lbl" style={{ marginTop:10 }}>Notes</label>
                          <textarea
                            value={draftObservation.text}
                            onChange={(e)=>setDraftObservation(prev => ({ ...prev, text: e.target.value }))}
                            placeholder="Observation details"
                          />
                          <label className="lbl" style={{ marginTop:10 }}>Caption</label>
                          <input
                            className="inp"
                            value={draftObservation.caption}
                            onChange={(e)=>setDraftObservation(prev => ({ ...prev, caption: e.target.value }))}
                            placeholder="Caption"
                          />
                          <label className="lbl" style={{ marginTop:10 }}>Photo URL</label>
                          <input
                            className="inp"
                            value={draftObservation.photo}
                            onChange={(e)=>setDraftObservation(prev => ({ ...prev, photo: e.target.value }))}
                            placeholder="Paste image link"
                          />
                          <button className={"btn " + (tool==="observation" ? "btnPrimary" : "")} style={{ marginTop:10 }} onClick={() => setTool("observation")}>Use Observation Tool</button>
                        </div>
                      )}

                      {(tool === "fixture" || tool === "opening") && (
                        <div className="card" style={{ borderColor:"rgba(15,118,110,0.35)" }}>
                          <label className="lbl">Items</label>
                          {tool === "opening" ? (
                            <>
                              <select
                                value={draftOpening.kind}
                                onChange={(e)=>setDraftOpening(prev => ({ ...prev, kind: e.target.value, label: e.target.value }))}
                              >
                                {["Door","Window","Half Wall","Garage Opening","Stair Opening"].map(v => (
                                  <option key={v} value={v}>{v}</option>
                                ))}
                              </select>
                              <input
                                className="inp"
                                style={{ marginTop:8 }}
                                value={draftOpening.label}
                                onChange={(e)=>setDraftOpening(prev => ({ ...prev, label: e.target.value }))}
                                placeholder="Label"
                              />
                            </>
                          ) : (
                            <>
                              <select
                                value={draftFixture.kind}
                                onChange={(e)=>setDraftFixture(prev => ({ ...prev, kind: e.target.value, label: e.target.value }))}
                              >
                                {["Toilet","Sink","Tub","Shower","Washer","Dryer","Refrigerator","Table","Bed","Counter","Furnace","Water Heater","Column","Custom"].map(v => (
                                  <option key={v} value={v}>{v}</option>
                                ))}
                              </select>
                              <input
                                className="inp"
                                style={{ marginTop:8 }}
                                value={draftFixture.label}
                                onChange={(e)=>setDraftFixture(prev => ({ ...prev, label: e.target.value }))}
                                placeholder="Label"
                              />
                            </>
                          )}
                          <div className="tiny" style={{ marginTop:8 }}>Tap the sheet to place the item. Dimensions are optional for fixtures.</div>
                        </div>
                      )}

                      <div className="card">
                        <div className="tiny" style={{ fontWeight:1200, marginBottom:8 }}>Rooms ({rooms.length})</div>
                        {rooms.length ? rooms.map(r => (
                          <div
                            key={r.id}
                            className={"listItem " + (selected.type==="room" && selected.id===r.id ? "selected":"")}
                            onClick={()=>selectEntity("room", r.id)}
                          >
                            <div style={{ minWidth:0 }}>
                              <b>{r.name}</b>
                              <span>{roomDimsText(r)}  {(r.kind || "room")}</span>
                            </div>
                            <div className="pill">Space</div>
                          </div>
                        )) : <div className="tiny">No rooms yet. Draw a boundary first.</div>}

                        <div className="hr"></div>

                        <div className="tiny" style={{ fontWeight:1200, margin:"8px 0" }}>Elevations ({elevPts.length})</div>
                        {elevPts.length ? elevPts.map(p => (
                          <div
                            key={p.id}
                            className={"listItem " + (selected.type==="elev" && selected.id===p.id ? "selected":"")}
                            onClick={()=>selectEntity("elev", p.id)}
                          >
                            <div style={{ minWidth:0 }}>
                              <b>{formatFeetInches(Number(p.reading) || 0)}</b>
                              <span>{(p.note || "").trim() ? p.note : "No note"}</span>
                            </div>
                            <div className="pill">Elev</div>
                          </div>
                        )) : <div className="tiny">No elevations yet.</div>}

                        <div className="hr"></div>

                        <div className="tiny" style={{ fontWeight:1200, margin:"8px 0" }}>Observations ({notes.length})</div>
                        {notes.length ? notes.map(n => (
                          <div
                            key={n.id}
                            className={"listItem " + (selected.type==="note" && selected.id===n.id ? "selected":"")}
                            onClick={()=>selectEntity("note", n.id)}
                          >
                            <div style={{ minWidth:0 }}>
                              <b>{n.category || "Observation"}</b>
                              <span>{n.text || "Observation"}</span>
                            </div>
                            <div className="pill">Obs</div>
                          </div>
                        )) : <div className="tiny">No observations yet.</div>}
                      </div>
                    </>
                  )}
                </div>
                </div>
              </div>
            </div>

            {panelCollapsed && (
              <button className="sideToggle" onClick={() => setPanelCollapsed(false)} title="Show sidebar">
                
              </button>
            )}

            {isMobile && (
              <div className="mobileDock">
                <button className="btn btnPrimary" onClick={()=>setMobilePanelOpen(true)}>Open Panel</button>
                <button className="btn" onClick={()=>setTool("select")}>Select</button>
                <button className="btn" onClick={()=>setTool("pan")}>Pan</button>
              </div>
            )}
          </>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
    </script>
  </body>
</html>
