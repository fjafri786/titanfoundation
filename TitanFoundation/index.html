<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <title>TitanFoundation (Foundation Diagram v1.0)</title>

    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      :root{
        --navy:#0B2A3A;
        --navy2:#0E3348;

        --bg:#F5F7FB;
        --panel:#FFFFFF;
        --border:#E5EAF1;
        --text:#0F172A;
        --sub:#64748B;

        --teal:#0BA7A5;

        --c-room:#2563EB;   /* blue */
        --c-elev:#16A34A;   /* green */
        --c-note:#9333EA;   /* purple */

        --shadow: 0 8px 18px rgba(2,6,23,0.08);
        --shadowSoft: 0 6px 12px rgba(2,6,23,0.06);
        --ring: 0 0 0 3px rgba(11,167,165,0.18);

        --glass: rgba(255,255,255,0.72);
        --glass2: rgba(255,255,255,0.86);
        --glassBorder: rgba(226,232,240,0.70);
      }

      *{ box-sizing:border-box; }
      html, body{
        margin:0;
        height:100%;
        overflow:hidden;
        background:var(--bg);
        color:var(--text);
        font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
        -webkit-text-size-adjust: 100%;
      }

      .app{
        display:grid;
        grid-template-columns: 1fr 380px;
        height:100vh;
        min-height: 100vh;
      }

      /* ===== Canvas Zone ===== */
      .canvasZone{
        position:relative;
        overflow:hidden;
        user-select:none;
        -webkit-user-select:none;
        background: #EEF2F7;
      }
      .viewport{
        position:absolute;
        inset:0;
        overflow:hidden;
        touch-action:none;
      }
      .stage{
        position:absolute;
        left:50%;
        top:50%;
        transform-origin: 0 0;
      }
      .sheet{
        width: var(--sheet-width, 1100px);
        height: var(--sheet-height, 780px);
        background:#fff;
        border-radius:18px;
        box-shadow: var(--shadow);
        border: 1px solid rgba(15,23,42,0.06);
        position:relative;
        overflow:hidden;
      }

      .gridSvg{
        position:absolute;
        inset:0;
        pointer-events:none;
      }
      .gridSvg .minor{ stroke: rgba(15,23,42,0.06); stroke-width:1; }
      .gridSvg .major{ stroke: rgba(15,23,42,0.10); stroke-width:1.2; }

      /* ===== Floating Toolbar ===== */
      .toolbar{
        position: fixed;
        left: 16px;
        top: 16px;
        display:flex;
        align-items:center;
        gap:10px;
        padding:10px 12px;
        background: #fff;
        border: 1px solid var(--glassBorder);
        box-shadow: var(--shadowSoft);
        z-index: 50;
        user-select:none;
        -webkit-user-select:none;
      }
      .toolBtn{
        display:inline-flex;
        align-items:center;
        justify-content:center;
        height:42px;
        padding:0 12px;
        border-radius: 999px;
        border:2px solid rgba(15,23,42,0.12);
        background:#fff;
        cursor:pointer;
        font-size:12px;
        font-weight:1100;
        letter-spacing:0.2px;
        color:#0B1220;
        white-space:nowrap;
        transition: transform 0.10s ease, box-shadow 0.10s ease, background 0.10s ease, border-color 0.10s ease;
      }
      .toolBtn:hover{ transform: translateY(-1px); box-shadow: 0 10px 16px rgba(2,6,23,0.10); background:#F8FAFC; }
      .toolBtn.active{
        background: linear-gradient(135deg, var(--navy2), var(--navy));
        color:#fff;
        border-color: rgba(14,51,72,0.65);
      }
      .toolBtn.room{ border-color: rgba(37,99,235,0.55); }
      .toolBtn.elev{ border-color: rgba(22,163,74,0.55); }
      .toolBtn.note{ border-color: rgba(147,51,234,0.55); }

      .tbDivider{ width:1px; height:26px; background: rgba(148,163,184,0.45); border-radius:999px; margin:0 4px; }

      /* ===== Bottom-right zoom controls ===== */
      .navTools{
        position:absolute;
        right:16px;
        bottom:16px;
        display:flex;
        flex-direction:column;
        gap:10px;
        z-index: 40;
      }
      .navCard{
        background: rgba(255,255,255,0.92);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(226,232,240,0.85);
        border-radius: 16px;
        box-shadow: var(--shadowSoft);
        padding: 10px;
        width: 230px;
      }
      .navRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
      .zBtns{ display:flex; gap:8px; flex-wrap:wrap; }
      .zBtn{
        padding:10px 11px;
        border-radius:12px;
        border:1px solid rgba(226,232,240,0.95);
        background:#fff;
        cursor:pointer;
        font-size:12px;
        font-weight:1100;
      }
      .zBtn:hover{ background:#F8FAFC; }
      .zReadout{
        font-size:12px;
        font-weight:1100;
        color: var(--navy);
        padding: 10px 11px;
        border-radius:12px;
        border:1px solid rgba(226,232,240,0.95);
        background: #fff;
        min-width: 74px;
        text-align:center;
      }
      .hint{
        margin-top:8px;
        font-size:11px;
        color: var(--sub);
        line-height:1.35;
      }

      /* ===== Shapes ===== */
      .spaceRect{
        position:absolute;
        border: 2px solid rgba(37,99,235,0.9);
        background: rgba(37,99,235,0.04);
        transform: translate(-50%,-50%);
      }
      .spaceRect.boundary{
        border-style: dashed;
        border-color: rgba(15,23,42,0.7);
        background: rgba(15,23,42,0.02);
      }
      .spaceRect.hallway{
        border-color: rgba(14,165,233,0.85);
        background: rgba(14,165,233,0.06);
      }
      .spaceRect.partial{
        border-style: dotted;
        border-color: rgba(100,116,139,0.8);
        background: rgba(148,163,184,0.12);
      }
      .spaceRect.locked{
        border-color: rgba(148,163,184,0.9);
      }
      .roomLabel{
        position:absolute;
        top: -8px;
        left: 50%;
        transform: translate(-50%,-100%);
        background: #fff;
        border:1px solid rgba(226,232,240,0.95);
        padding:6px 10px;
        font-size:11px;
        font-weight:1100;
        color:#0B1220;
        display:flex;
        gap:8px;
        align-items:center;
        white-space:nowrap;
      }
      .roomLabel .roomName{ font-weight:1200; }
      .roomLabel .roomMeta{ color: rgba(100,116,139,1); }
      .roomLabel .roomKind{
        font-size:10px;
        padding:2px 6px;
        border:1px solid rgba(226,232,240,0.95);
        background:#fff;
        color:#0B1220;
      }

      .elevDot{
        position:absolute;
        width: 12px;
        height: 12px;
        border: 3px solid rgba(255,255,255,0.95);
        transform: translate(-50%,-50%);
      }
      .elevBadge{
        position:absolute;
        transform: translate(-50%,-115%);
        padding:6px 8px;
        border: 1px solid rgba(226,232,240,0.95);
        background: #fff;
        font-size:11px;
        font-weight:1100;
        white-space:nowrap;
        color:#0B1220;
        display:flex;
        gap:6px;
        align-items:center;
      }
      .elevBadge small{
        font-weight:1200;
        color: rgba(100,116,139,1);
        margin-left:0;
      }

      .noteMarker{
        position:absolute;
        width: 30px;
        height: 30px;
        background: rgba(147,51,234,0.9);
        color:#fff;
        display:flex;
        align-items:center;
        justify-content:center;
        font-weight:1300;
        font-size:12px;
        border: 2px solid rgba(255,255,255,0.95);
        transform: translate(-50%,-50%);
      }

      .fixtureRect,
      .openingRect{
        position:absolute;
        transform: translate(-50%,-50%);
        border: 2px solid rgba(15,23,42,0.7);
        background: rgba(248,250,252,0.9);
        display:flex;
        align-items:center;
        justify-content:center;
        text-align:center;
        padding:4px;
      }
      .openingRect{
        border-style: dashed;
        background: rgba(226,232,240,0.7);
      }
      .fixtureRect.locked,
      .openingRect.locked{
        border-color: rgba(148,163,184,0.9);
      }
      .fixtureLabel{
        font-size:10px;
        font-weight:1200;
        color:#0B1220;
        text-transform:uppercase;
      }

      .measureSvg{
        position:absolute;
        inset:0;
        pointer-events:none;
      }
      .measureSvg g{ pointer-events:auto; }
      .measureLine{
        stroke: rgba(15,23,42,0.9);
        stroke-width:2;
        stroke-dasharray: 6 4;
      }
      .measureLine.draft{
        stroke: rgba(100,116,139,0.6);
      }
      .measureLabel{
        font-size:10px;
        font-weight:1200;
        fill: rgba(15,23,42,0.9);
        paint-order: stroke;
        stroke: #fff;
        stroke-width: 3;
      }
      .heatSvg{
        position:absolute;
        inset:0;
        pointer-events:none;
        mix-blend-mode:multiply;
      }

      /* ===== Sidebar ===== */
      .panel{
        background: var(--panel);
        border-left: 1px solid var(--border);
        display:flex;
        flex-direction:column;
        box-shadow: -10px 0 26px rgba(2,6,23,0.05);
        height:100vh;
        min-width: 0;
        position:relative;
      }
      .panelCollapsed{
        width: 56px;
        min-width:56px;
        max-width:56px;
      }

      .pHeader{
        padding:14px 14px 12px;
        background: #0B2A3A;
        color:#fff;
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
      }
      .pHeader .titleWrap{
        display:flex;
        flex-direction:column;
        gap:2px;
        min-width:0;
      }
      .pHeader .small{
        font-size:11px;
        font-weight:1100;
        letter-spacing:0.5px;
        text-transform:uppercase;
        opacity:0.9;
      }
      .pHeader .big{
        font-size:18px;
        font-weight:1300;
        line-height:1.15;
        white-space:nowrap;
        overflow:hidden;
        text-overflow:ellipsis;
      }

      .collapseBtn{
        width:40px;
        height:40px;
        border-radius:14px;
        border:1px solid rgba(255,255,255,0.22);
        background: rgba(255,255,255,0.12);
        cursor:pointer;
        display:flex;
        align-items:center;
        justify-content:center;
        flex:0 0 auto;
      }
      .collapseBtn:hover{ background: rgba(255,255,255,0.18); }

      .pScroll{
        flex:1;
        overflow:auto;
        -webkit-overflow-scrolling: touch;
        padding:14px;
        display:flex;
        flex-direction:column;
        gap:12px;
        min-width:0;
      }
      .panelCollapsed .pScroll{ display:none; }

      .card{
        background:#fff;
        border:1px solid var(--border);
        border-radius:16px;
        padding:12px;
        box-shadow: var(--shadowSoft);
      }
      .lbl{
        display:block;
        font-size:11px;
        font-weight:1100;
        text-transform:uppercase;
        color: var(--sub);
        letter-spacing:0.45px;
        margin-bottom:8px;
      }
      .inp, select, textarea{
        width:100%;
        padding:12px 12px;
        font-size:14px;
        border:1px solid var(--border);
        border-radius:14px;
        background:#fff;
        outline:none;
        color:var(--text);
      }
      textarea{ min-height:72px; resize:vertical; }
      .inp:focus, select:focus, textarea:focus{
        border-color: var(--teal);
        box-shadow: var(--ring);
      }

      .row{ display:flex; gap:10px; align-items:center; }
      .row > *{ flex:1; }

      .btn{
        padding:12px 12px;
        border-radius:14px;
        border:1px solid var(--border);
        background:#fff;
        cursor:pointer;
        font-size:13px;
        font-weight:1100;
        user-select:none;
        transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.08s ease;
        display:inline-flex;
        align-items:center;
        justify-content:center;
        gap:8px;
      }
      .btn:hover{ transform: translateY(-1px); box-shadow: 0 10px 16px rgba(2,6,23,0.08); background:#F8FAFC; }
      .btnPrimary{
        border-color: rgba(11,167,165,0.35);
        color: var(--teal);
        background: rgba(11,167,165,0.06);
      }
      .btnDanger{
        border-color: rgba(220,38,38,0.35);
        color: #B91C1C;
        background: rgba(220,38,38,0.06);
      }
      .tiny{ color: var(--sub); font-size:12px; line-height:1.35; }
      .hr{ height:1px; background: rgba(226,232,240,0.95); margin: 8px 0; }

      .listItem{
        border:1px solid rgba(226,232,240,0.95);
        border-radius:14px;
        padding:10px;
        cursor:pointer;
        background:#fff;
        display:flex;
        align-items:flex-start;
        justify-content:space-between;
        gap:10px;
      }
      .listItem:hover{ background:#F8FAFC; }
      .listItem.selected{ box-shadow: var(--ring); border-color: rgba(11,167,165,0.55); background:#F1F5F9; }
      .listItem b{ display:block; font-size:13px; font-weight:1200; }
      .listItem span{ display:block; font-size:12px; color: var(--sub); margin-top:4px; }
      .pill{
        font-size:11px;
        font-weight:1200;
        padding:4px 8px;
        border:1px solid rgba(226,232,240,0.95);
        background:#fff;
        white-space:nowrap;
        color:#0B1220;
      }

      /* Square, engineering-first UI */
      .sheet,
      .toolbar,
      .toolBtn,
      .navCard,
      .zBtn,
      .zReadout,
      .roomLabel,
      .pHeader,
      .collapseBtn,
      .card,
      .inp,
      select,
      textarea,
      .btn,
      .listItem,
      .pill,
      .noteMarker,
      .fixtureRect,
      .openingRect,
      .spaceRect,
      .panel{
        border-radius: 0 !important;
      }

      details.section{
        border:1px solid var(--border);
        background:#fff;
      }
      details.section summary{
        cursor:pointer;
        list-style:none;
        padding:10px 12px;
        font-size:12px;
        font-weight:1200;
        text-transform:uppercase;
        letter-spacing:0.4px;
        color: var(--sub);
        border-bottom:1px solid var(--border);
      }
      details.section summary::-webkit-details-marker{ display:none; }
      details.section[open] summary{
        color:#0B1220;
        background:#F8FAFC;
      }
      details.section .sectionBody{
        padding:12px;
        display:grid;
        gap:10px;
      }

      /* Responsive */
      @media (max-width: 980px){
        .app{ grid-template-columns: 1fr 340px; }
      }
      @media (max-width: 820px){
        .app{ grid-template-columns: 1fr; }
        .panel{
          position:fixed;
          right:0;
          top:0;
          bottom:0;
          width:min(100%, 420px);
          transform: translateX(100%);
          transition: transform 0.2s ease;
          z-index: 70;
        }
        .panel.mobileOpen{ transform: translateX(0); }
        .panelOverlay{
          position:fixed;
          inset:0;
          background: rgba(15,23,42,0.35);
          opacity:0;
          pointer-events:none;
          transition: opacity 0.2s ease;
          z-index: 65;
        }
        .panelOverlay.show{
          opacity:1;
          pointer-events:auto;
        }
        .toolbar{ left: 12px; top: 12px; }
        .navTools{ right:12px; bottom:12px; }
        .navCard{ width: 210px; }
        .mobileDock{
          position: fixed;
          left: 12px;
          right: 12px;
          bottom: 16px;
          display:flex;
          gap:10px;
          z-index: 60;
        }
        .mobileDock .btn{ flex:1 1 0; }
      }
    </style>
  </head>

  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useEffect, useMemo, useRef, useState, useCallback } = React;

      const STORAGE_KEY = "titanfoundation.v1.state";
      const uid = () => Math.random().toString(36).slice(2,10);
      const clamp = (v, min, max) => Math.min(Math.max(v, min), max);

      function downloadText(filename, text){
        const blob = new Blob([text], { type:"application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 200);
      }

      function App(){
        const viewportRef = useRef(null);

        // View (pan/zoom)
        const [view, setView] = useState({ scale: 1.0, tx: 0, ty: 0 });
        const [viewportSize, setViewportSize] = useState({ w: window.innerWidth, h: window.innerHeight });

        // Tools
        // select | draw | elev | note | pan | fixture | opening | measure
        const [tool, setTool] = useState("select");
        const [drawType, setDrawType] = useState("room");
        const [draftElevation, setDraftElevation] = useState({ reading: 0.0, note: "" });
        const [draftNote, setDraftNote] = useState("Observation");
        const [draftFixture, setDraftFixture] = useState({ kind: "Washer", label: "Washer", w: 40, h: 40 });
        const [draftOpening, setDraftOpening] = useState({ kind: "Door", label: "Door", w: 44, h: 14 });
        const [measureDraft, setMeasureDraft] = useState(null);
        const [showHeatmap, setShowHeatmap] = useState(true);
        const [zeroMode, setZeroMode] = useState("auto");
        const [customZero, setCustomZero] = useState(0);

        // Sheet
        const SHEET = { w: 1100, h: 780 };

        // Project data
        const [projectName, setProjectName] = useState("Enter Name");
        const [frontFaces, setFrontFaces] = useState("North");

        // Scale: feet per grid major (10px minor, 50px major). This is a simple helper, not a survey-grade scale.
        const [scaleFtPerMajor, setScaleFtPerMajor] = useState(5); // 1 major grid ~ 5 ft

        // Leak indicators (simple)
        const [leak, setLeak] = useState({
          activeLeakReported: false,
          plumbingSupplyNearby: false,
          drainLineNearby: false,
          stainingObserved: false,
          elevatedMoistureReadings: false,
          notes: ""
        });

        // Entities
        const [rooms, setRooms] = useState([]);      // {id, cx, cy, w, h, name, kind, locked}
        const [elevPts, setElevPts] = useState([]);  // {id, x, y, reading, note}
        const [notes, setNotes] = useState([]);      // {id, x, y, text, photo}
        const [fixtures, setFixtures] = useState([]); // {id, x, y, w, h, kind, label, locked}
        const [openings, setOpenings] = useState([]); // {id, x, y, w, h, kind, label, locked}
        const [measurements, setMeasurements] = useState([]); // {id, x1, y1, x2, y2}

        const [selected, setSelected] = useState({ type:null, id:null });

        // Sidebar
        const [panelCollapsed, setPanelCollapsed] = useState(false);
        const [mobilePanelOpen, setMobilePanelOpen] = useState(false);

        // Drawing / dragging state
        // drag: {mode:'pan'|'room-draw'|'move', start:{x,y}, startWorld:{x,y}, entity, origin, rectStartWorld}
        const [drag, setDrag] = useState(null);

        // Mobile detection
        useEffect(() => {
          const onResize = () => setViewportSize({ w: window.innerWidth, h: window.innerHeight });
          window.addEventListener("resize", onResize);
          return () => window.removeEventListener("resize", onResize);
        }, []);
        const isMobile = viewportSize.w <= 820;

        useEffect(() => {
          if(tool !== "measure") setMeasureDraft(null);
        }, [tool]);

        // World <-> screen helpers
        const screenToWorld = (clientX, clientY) => {
          const v = viewportRef.current?.getBoundingClientRect();
          if(!v) return { x:0, y:0 };
          const sx = clientX - v.left;
          const sy = clientY - v.top;
          // stage is centered at (v.width/2, v.height/2) + tx/ty, then scaled, then sheet is centered at 0,0
          // We'll treat world coords with origin at sheet center.
          const x = (sx - v.width/2 - view.tx) / view.scale;
          const y = (sy - v.height/2 - view.ty) / view.scale;
          return { x, y };
        };

        const worldToSheetPx = (wx, wy) => {
          // world origin is sheet center; convert to sheet local px
          return { x: wx + SHEET.w/2, y: wy + SHEET.h/2 };
        };

        const sheetPxToWorld = (sx, sy) => {
          return { x: sx - SHEET.w/2, y: sy - SHEET.h/2 };
        };

        const withinSheet = (sheetX, sheetY) => sheetX >= 0 && sheetY >= 0 && sheetX <= SHEET.w && sheetY <= SHEET.h;

        // Zoom helpers
        const setScaleAnchored = (nextScale, anchorClient) => {
          const v = viewportRef.current?.getBoundingClientRect();
          if(!v) return;
          const scale = clamp(nextScale, 0.35, 3.0);

          if(!anchorClient){
            setView(prev => ({ ...prev, scale }));
            return;
          }

          setView(prev => {
            const ax = anchorClient.x - v.left;
            const ay = anchorClient.y - v.top;
            const s0 = prev.scale;
            const s1 = scale;

            const tx0 = prev.tx;
            const ty0 = prev.ty;

            const dx = ax - v.width/2 - tx0;
            const dy = ay - v.height/2 - ty0;

            const tx1 = tx0 + dx * (1 - s1/s0);
            const ty1 = ty0 + dy * (1 - s1/s0);

            return { scale: s1, tx: tx1, ty: ty1 };
          });
        };

        const zoomIn = () => setScaleAnchored(view.scale * 1.15);
        const zoomOut = () => setScaleAnchored(view.scale / 1.15);
        const zoomReset = () => setView({ scale: 1.0, tx: 0, ty: 0 });

        const zoomFit = () => {
          const v = viewportRef.current?.getBoundingClientRect();
          if(!v) return;
          const pad = 90;
          const sx = (v.width - pad) / SHEET.w;
          const sy = (v.height - pad) / SHEET.h;
          const s = clamp(Math.min(sx, sy), 0.55, 3.0);
          setView({ scale: s, tx: 0, ty: 0 });
        };

        useEffect(() => { setTimeout(() => zoomFit(), 0); }, []);

        // Wheel (desktop)
        const onWheel = (e) => {
          e.preventDefault();
          const isZoom = e.ctrlKey || e.metaKey;
          if(isZoom){
            const delta = -e.deltaY;
            const factor = delta > 0 ? 1.08 : 1/1.08;
            setScaleAnchored(view.scale * factor, { x: e.clientX, y: e.clientY });
          } else {
            setView(prev => ({ ...prev, tx: prev.tx - e.deltaX, ty: prev.ty - e.deltaY }));
          }
        };

        // Pinch + two-finger pan (touch)
        const pointersRef = useRef(new Map()); // pointerId -> {x,y}
        const pinchRef = useRef(null);

        const startPinchIfTwo = () => {
          const pts = [...pointersRef.current.values()];
          if(pts.length !== 2) return;
          const [a,b] = pts;
          const dist = Math.hypot(b.x-a.x, b.y-a.y) || 1;
          const center = { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
          pinchRef.current = {
            startDist: dist,
            startScale: view.scale,
            startTx: view.tx,
            startTy: view.ty,
            centerX: center.x,
            centerY: center.y,
            lastCenterX: center.x,
            lastCenterY: center.y
          };
        };

        const updatePinch = () => {
          const pts = [...pointersRef.current.values()];
          if(pts.length !== 2 || !pinchRef.current) return;
          const [a,b] = pts;
          const dist = Math.hypot(b.x-a.x, b.y-a.y) || 1;
          const center = { x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
          const ratio = dist / pinchRef.current.startDist;
          const targetScale = clamp(pinchRef.current.startScale * ratio, 0.35, 3.0);

          const dcx = center.x - pinchRef.current.lastCenterX;
          const dcy = center.y - pinchRef.current.lastCenterY;

          setView(prev => {
            const v = viewportRef.current?.getBoundingClientRect();
            if(!v) return prev;

            const ax = pinchRef.current.centerX - v.left;
            const ay = pinchRef.current.centerY - v.top;

            const s0 = pinchRef.current.startScale || 1;
            const s1 = targetScale;

            const tx0 = pinchRef.current.startTx;
            const ty0 = pinchRef.current.startTy;

            const dx0 = ax - v.width/2 - tx0;
            const dy0 = ay - v.height/2 - ty0;

            const tx1 = tx0 + dx0 * (1 - s1/s0);
            const ty1 = ty0 + dy0 * (1 - s1/s0);

            return { scale: s1, tx: tx1 + dcx, ty: ty1 + dcy };
          });

          pinchRef.current.lastCenterX = center.x;
          pinchRef.current.lastCenterY = center.y;
        };

        // Elevation summary + grading buckets
        const elevSummary = useMemo(() => {
          if(!elevPts.length) return { min:null, max:null, diff:null, mid:null };
          const vals = elevPts.map(p => Number(p.reading)).filter(v => Number.isFinite(v));
          if(!vals.length) return { min:null, max:null, diff:null, mid:null };
          const min = Math.min(...vals);
          const max = Math.max(...vals);
          const diff = max - min;
          const mid = min + diff / 2;
          return { min, max, diff, mid };
        }, [elevPts]);

        const zeroRef = useMemo(() => {
          if(zeroMode === "custom") return Number(customZero) || 0;
          return Number.isFinite(elevSummary.mid) ? elevSummary.mid : 0;
        }, [zeroMode, customZero, elevSummary.mid]);

        const classifyElev = (value) => {
          const { min, max } = elevSummary;
          if(min == null || max == null || min === max) return { tag:"MID", t:0.5 };
          const t = (value - min) / (max - min); // 0..1
          if(t <= 0.33) return { tag:"LOW", t };
          if(t >= 0.67) return { tag:"HIGH", t };
          return { tag:"MID", t };
        };

        const elevColor = (value) => {
          const { min, max } = elevSummary;
          if(min == null || max == null || min === max) return "rgba(22,163,74,0.95)";
          const t = clamp((value - min) / (max - min), 0, 1);
          // green -> amber -> red-ish (simple gradient via RGB interpolation)
          // low: green, mid: amber, high: red
          const lerp = (a,b,u) => Math.round(a + (b-a)*u);
          let r,g,b;
          if(t < 0.5){
            const u = t/0.5;
            r = lerp(22, 245, u);
            g = lerp(163, 158, u);
            b = lerp(74, 11, u);
          } else {
            const u = (t-0.5)/0.5;
            r = lerp(245, 220, u);
            g = lerp(158, 38, u);
            b = lerp(11, 38, u);
          }
          return `rgba(${r},${g},${b},0.95)`;
        };

        // Save/Load
        const buildState = useCallback(() => ({
          projectName,
          frontFaces,
          scaleFtPerMajor,
          leak,
          rooms,
          elevPts,
          notes,
          fixtures,
          openings,
          measurements,
          drawType,
          view
        }), [projectName, frontFaces, scaleFtPerMajor, leak, rooms, elevPts, notes, fixtures, openings, measurements, drawType, view]);

        const saveState = useCallback((source="manual") => {
          try{
            localStorage.setItem(STORAGE_KEY, JSON.stringify(buildState()));
          }catch(e){
            console.warn("Save failed", e);
          }
        }, [buildState]);

        const loadState = useCallback(() => {
          const raw = localStorage.getItem(STORAGE_KEY);
          if(!raw) return;
          try{
            const s = JSON.parse(raw);
            setProjectName(s.projectName ?? "Enter Name");
            setFrontFaces(s.frontFaces ?? "North");
            setScaleFtPerMajor(Number.isFinite(s.scaleFtPerMajor) ? s.scaleFtPerMajor : 5);
            setLeak(s.leak ?? {
              activeLeakReported:false, plumbingSupplyNearby:false, drainLineNearby:false,
              stainingObserved:false, elevatedMoistureReadings:false, notes:""
            });
            setRooms(Array.isArray(s.rooms) ? s.rooms : []);
            setElevPts(Array.isArray(s.elevPts) ? s.elevPts : []);
            setNotes(Array.isArray(s.notes) ? s.notes : []);
            setFixtures(Array.isArray(s.fixtures) ? s.fixtures : []);
            setOpenings(Array.isArray(s.openings) ? s.openings : []);
            setMeasurements(Array.isArray(s.measurements) ? s.measurements : []);
            setDrawType(s.drawType ?? "room");
            setView(s.view ?? { scale:1.0, tx:0, ty:0 });
          }catch(e){
            console.warn("Load failed", e);
          }
        }, []);

        useEffect(() => { loadState(); }, []);
        useEffect(() => {
          const id = setInterval(() => saveState("auto"), 5*60*1000);
          return () => clearInterval(id);
        }, [saveState]);

        // Selection helpers
        const selectEntity = (type, id) => {
          setSelected({ type, id });
          if(isMobile) setMobilePanelOpen(true);
        };

        const selectedEntity = useMemo(() => {
          const { type, id } = selected;
          if(!type || !id) return null;
          if(type === "room") return rooms.find(r => r.id === id) || null;
          if(type === "elev") return elevPts.find(p => p.id === id) || null;
          if(type === "note") return notes.find(n => n.id === id) || null;
          if(type === "fixture") return fixtures.find(f => f.id === id) || null;
          if(type === "opening") return openings.find(o => o.id === id) || null;
          if(type === "measure") return measurements.find(m => m.id === id) || null;
          return null;
        }, [selected, rooms, elevPts, notes, fixtures, openings, measurements]);

        const updateSelected = (patch) => {
          const { type, id } = selected;
          if(!type || !id) return;
          if(type === "room"){
            setRooms(prev => prev.map(r => r.id === id ? { ...r, ...patch } : r));
          }
          if(type === "elev"){
            setElevPts(prev => prev.map(p => p.id === id ? { ...p, ...patch } : p));
          }
          if(type === "note"){
            setNotes(prev => prev.map(n => n.id === id ? { ...n, ...patch } : n));
          }
          if(type === "fixture"){
            setFixtures(prev => prev.map(f => f.id === id ? { ...f, ...patch } : f));
          }
          if(type === "opening"){
            setOpenings(prev => prev.map(o => o.id === id ? { ...o, ...patch } : o));
          }
        };

        const deleteSelected = () => {
          const { type, id } = selected;
          if(!type || !id) return;
          if(type === "room") setRooms(prev => prev.filter(r => r.id !== id));
          if(type === "elev") setElevPts(prev => prev.filter(p => p.id !== id));
          if(type === "note") setNotes(prev => prev.filter(n => n.id !== id));
          if(type === "fixture") setFixtures(prev => prev.filter(f => f.id !== id));
          if(type === "opening") setOpenings(prev => prev.filter(o => o.id !== id));
          if(type === "measure") setMeasurements(prev => prev.filter(m => m.id !== id));
          setSelected({ type:null, id:null });
        };

        const distanceToSegment = (p, a, b) => {
          const vx = b.x - a.x;
          const vy = b.y - a.y;
          const wx = p.x - a.x;
          const wy = p.y - a.y;
          const c1 = vx * wx + vy * wy;
          if(c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
          const c2 = vx * vx + vy * vy;
          if(c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
          const t = c1 / c2;
          const proj = { x: a.x + t * vx, y: a.y + t * vy };
          return Math.hypot(p.x - proj.x, p.y - proj.y);
        };

        const nextSpaceName = (kind) => {
          const labelMap = {
            room: "Room",
            boundary: "Boundary",
            hallway: "Hallway",
            partial: "Partial"
          };
          const count = rooms.filter(r => r.kind === kind).length + 1;
          return `${labelMap[kind] || "Space"} ${count}`;
        };

        // Pointer handling on viewport
        const onPointerDown = (e) => {
          // Track pointers for pinch
          pointersRef.current.set(e.pointerId, { x:e.clientX, y:e.clientY });
          if(pointersRef.current.size === 2){
            startPinchIfTwo();
          }

          // If pinch is active, don't start drawing
          if(pointersRef.current.size >= 2) return;

          e.preventDefault();
          const world = screenToWorld(e.clientX, e.clientY);
          const sheet = worldToSheetPx(world.x, world.y);

          // Right now: tool can override
          if(tool === "pan"){
            setDrag({ mode:"pan", start:{ x:e.clientX, y:e.clientY }, origin:{ tx:view.tx, ty:view.ty } });
            try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
            return;
          }

          // Click outside sheet: pan
          if(!withinSheet(sheet.x, sheet.y)){
            setDrag({ mode:"pan", start:{ x:e.clientX, y:e.clientY }, origin:{ tx:view.tx, ty:view.ty } });
            try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
            return;
          }

          // If selecting, attempt hit test first
          if(tool === "select"){
            // hit test order: note -> elev -> fixture -> opening -> measure -> room
            const hitNote = [...notes].reverse().find(n => {
              const dx = n.x - sheet.x, dy = n.y - sheet.y;
              return Math.hypot(dx,dy) <= 22;
            });
            if(hitNote){
              selectEntity("note", hitNote.id);
              setDrag({ mode:"move", entity:{ type:"note", id:hitNote.id }, start:{x:e.clientX,y:e.clientY}, startWorld:world });
              try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
              return;
            }

            const hitElev = [...elevPts].reverse().find(p => {
              const dx = p.x - sheet.x, dy = p.y - sheet.y;
              return Math.hypot(dx,dy) <= 18;
            });
            if(hitElev){
              selectEntity("elev", hitElev.id);
              setDrag({ mode:"move", entity:{ type:"elev", id:hitElev.id }, start:{x:e.clientX,y:e.clientY}, startWorld:world });
              try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
              return;
            }

            const hitFixture = [...fixtures].reverse().find(f => {
              const left = f.x - f.w/2, right = f.x + f.w/2;
              const top = f.y - f.h/2, bottom = f.y + f.h/2;
              return sheet.x >= left && sheet.x <= right && sheet.y >= top && sheet.y <= bottom;
            });
            if(hitFixture){
              selectEntity("fixture", hitFixture.id);
              if(!hitFixture.locked){
                setDrag({ mode:"move", entity:{ type:"fixture", id:hitFixture.id }, start:{x:e.clientX,y:e.clientY}, startWorld:world });
                try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
              }
              return;
            }

            const hitOpening = [...openings].reverse().find(o => {
              const left = o.x - o.w/2, right = o.x + o.w/2;
              const top = o.y - o.h/2, bottom = o.y + o.h/2;
              return sheet.x >= left && sheet.x <= right && sheet.y >= top && sheet.y <= bottom;
            });
            if(hitOpening){
              selectEntity("opening", hitOpening.id);
              if(!hitOpening.locked){
                setDrag({ mode:"move", entity:{ type:"opening", id:hitOpening.id }, start:{x:e.clientX,y:e.clientY}, startWorld:world });
                try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
              }
              return;
            }

            const hitMeasure = [...measurements].reverse().find(m => {
              return distanceToSegment(sheet, { x: m.x1, y: m.y1 }, { x: m.x2, y: m.y2 }) <= 10;
            });
            if(hitMeasure){
              selectEntity("measure", hitMeasure.id);
              return;
            }

            const hitRoom = [...rooms].reverse().find(r => {
              const left = r.cx - r.w/2, right = r.cx + r.w/2;
              const top = r.cy - r.h/2, bottom = r.cy + r.h/2;
              return sheet.x >= left && sheet.x <= right && sheet.y >= top && sheet.y <= bottom;
            });
            if(hitRoom){
              selectEntity("room", hitRoom.id);
              if(!hitRoom.locked){
                setDrag({ mode:"move", entity:{ type:"room", id:hitRoom.id }, start:{x:e.clientX,y:e.clientY}, startWorld:world });
                try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
              }
              return;
            }

            // empty click clears selection
            setSelected({ type:null, id:null });
            return;
          }

          if(tool === "draw"){
            // start rect draw
            const start = sheet;
            const newId = uid();
            const newRoom = {
              id:newId,
              cx:start.x,
              cy:start.y,
              w:10,
              h:10,
              name: nextSpaceName(drawType),
              kind: drawType,
              locked: false
            };
            setRooms(prev => [...prev, newRoom]);
            selectEntity("room", newId);
            setDrag({ mode:"room-draw", id:newId, rectStartWorld: world });
            try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
            return;
          }

          if(tool === "elev"){
            const val = Number(draftElevation.reading);
            if(!Number.isFinite(val)) return;
            const id = uid();
            setElevPts(prev => [...prev, { id, x:sheet.x, y:sheet.y, reading: val, note: draftElevation.note || "" }]);
            selectEntity("elev", id);
            return;
          }

          if(tool === "note"){
            const id = uid();
            setNotes(prev => [...prev, { id, x:sheet.x, y:sheet.y, text: draftNote || "Note", photo: "" }]);
            selectEntity("note", id);
            return;
          }

          if(tool === "fixture"){
            const id = uid();
            setFixtures(prev => [...prev, {
              id,
              x: sheet.x,
              y: sheet.y,
              w: Number(draftFixture.w) || 40,
              h: Number(draftFixture.h) || 40,
              kind: draftFixture.kind,
              label: draftFixture.label || draftFixture.kind,
              locked: false
            }]);
            selectEntity("fixture", id);
            return;
          }

          if(tool === "opening"){
            const id = uid();
            setOpenings(prev => [...prev, {
              id,
              x: sheet.x,
              y: sheet.y,
              w: Number(draftOpening.w) || 44,
              h: Number(draftOpening.h) || 14,
              kind: draftOpening.kind,
              label: draftOpening.label || draftOpening.kind,
              locked: false
            }]);
            selectEntity("opening", id);
            return;
          }

          if(tool === "measure"){
            if(!measureDraft){
              setMeasureDraft({ x1: sheet.x, y1: sheet.y, x2: sheet.x, y2: sheet.y });
              return;
            }
            const id = uid();
            setMeasurements(prev => [...prev, { id, x1: measureDraft.x1, y1: measureDraft.y1, x2: sheet.x, y2: sheet.y }]);
            setMeasureDraft(null);
            selectEntity("measure", id);
            return;
          }
        };

        const onPointerMove = (e) => {
          // pinch update
          if(pointersRef.current.has(e.pointerId)){
            pointersRef.current.set(e.pointerId, { x:e.clientX, y:e.clientY });
            if(pointersRef.current.size === 2){
              updatePinch();
              return;
            }
          }

          if(tool === "measure" && measureDraft){
            const world = screenToWorld(e.clientX, e.clientY);
            const sheet = worldToSheetPx(world.x, world.y);
            setMeasureDraft(prev => prev ? ({ ...prev, x2: sheet.x, y2: sheet.y }) : prev);
          }

          if(!drag) return;
          e.preventDefault();

          if(drag.mode === "pan"){
            const dx = e.clientX - drag.start.x;
            const dy = e.clientY - drag.start.y;
            setView(prev => ({ ...prev, tx: drag.origin.tx + dx, ty: drag.origin.ty + dy }));
            return;
          }

          if(drag.mode === "room-draw"){
            const world = screenToWorld(e.clientX, e.clientY);
            const sheet = worldToSheetPx(world.x, world.y);
            const startWorld = drag.rectStartWorld;
            const startSheet = worldToSheetPx(startWorld.x, startWorld.y);

            const id = drag.id;
            const left = Math.min(startSheet.x, sheet.x);
            const right = Math.max(startSheet.x, sheet.x);
            const top = Math.min(startSheet.y, sheet.y);
            const bottom = Math.max(startSheet.y, sheet.y);

            const cx = (left+right)/2;
            const cy = (top+bottom)/2;
            const w = Math.max(24, right-left);
            const h = Math.max(24, bottom-top);

            setRooms(prev => prev.map(r => r.id === id ? { ...r, cx, cy, w, h } : r));
            return;
          }

          if(drag.mode === "move"){
            const world = screenToWorld(e.clientX, e.clientY);
            const deltaWorld = { x: world.x - drag.startWorld.x, y: world.y - drag.startWorld.y };
            const deltaSheet = { x: deltaWorld.x, y: deltaWorld.y }; // since world is sheet-centered in px units
            const { type, id } = drag.entity;

            if(type === "room"){
              setRooms(prev => prev.map(r => r.id === id ? { ...r, cx: r.cx + deltaSheet.x, cy: r.cy + deltaSheet.y } : r));
            }
            if(type === "elev"){
              setElevPts(prev => prev.map(p => p.id === id ? { ...p, x: p.x + deltaSheet.x, y: p.y + deltaSheet.y } : p));
            }
            if(type === "note"){
              setNotes(prev => prev.map(n => n.id === id ? { ...n, x: n.x + deltaSheet.x, y: n.y + deltaSheet.y } : n));
            }
            if(type === "fixture"){
              setFixtures(prev => prev.map(f => f.id === id ? { ...f, x: f.x + deltaSheet.x, y: f.y + deltaSheet.y } : f));
            }
            if(type === "opening"){
              setOpenings(prev => prev.map(o => o.id === id ? { ...o, x: o.x + deltaSheet.x, y: o.y + deltaSheet.y } : o));
            }

            // update baseline for smooth drag
            setDrag(prev => prev ? ({ ...prev, startWorld: world }) : prev);
            return;
          }
        };

        const onPointerUp = (e) => {
          // remove pointer
          pointersRef.current.delete(e.pointerId);
          if(pointersRef.current.size < 2){
            pinchRef.current = null;
          }
          if(drag){
            setDrag(null);
            try { e.currentTarget.releasePointerCapture(e.pointerId); } catch {}
          }
        };

        // Export/Import
        const exportJson = () => {
          const s = buildState();
          downloadText(`TitanFoundation_${projectName.replace(/\s+/g,"_") || "Project"}.json`, JSON.stringify(s, null, 2));
        };

        const importJson = async (file) => {
          if(!file) return;
          try{
            const text = await file.text();
            const s = JSON.parse(text);

            setProjectName(s.projectName ?? "Enter Name");
            setFrontFaces(s.frontFaces ?? "North");
            setScaleFtPerMajor(Number.isFinite(s.scaleFtPerMajor) ? s.scaleFtPerMajor : 5);
            setLeak(s.leak ?? leak);
            setRooms(Array.isArray(s.rooms) ? s.rooms : []);
            setElevPts(Array.isArray(s.elevPts) ? s.elevPts : []);
            setNotes(Array.isArray(s.notes) ? s.notes : []);
            setFixtures(Array.isArray(s.fixtures) ? s.fixtures : []);
            setOpenings(Array.isArray(s.openings) ? s.openings : []);
            setMeasurements(Array.isArray(s.measurements) ? s.measurements : []);
            setDrawType(s.drawType ?? "room");
            setView(s.view ?? { scale:1.0, tx:0, ty:0 });

            setSelected({ type:null, id:null });
            if(isMobile) setMobilePanelOpen(true);
          }catch(err){
            alert("Import failed. Please verify it is a TitanFoundation JSON export.");
          }
        };

        // Derived room dimensions (approx) using scaleFtPerMajor; major grid is 50px
        const pxPerMajor = 50;
        const roomDimsText = (room) => {
          const ftPerPx = scaleFtPerMajor / pxPerMajor;
          const wFt = room.w * ftPerPx;
          const hFt = room.h * ftPerPx;
          const fmt = (v) => (Math.round(v*10)/10).toFixed(1);
          return `${fmt(wFt)} ft Ã— ${fmt(hFt)} ft`;
        };

        const fmtFeet = (v) => (Math.round(v * 10) / 10).toFixed(1);
        const pxToFt = (px) => (scaleFtPerMajor / pxPerMajor) * px;
        const measurementText = (m) => {
          const dist = Math.hypot(m.x2 - m.x1, m.y2 - m.y1);
          return `${fmtFeet(pxToFt(dist))} ft`;
        };

        // Render
        const panelClass = [
          "panel",
          panelCollapsed ? "panelCollapsed" : "",
          (isMobile && mobilePanelOpen) ? "mobileOpen" : ""
        ].join(" ").trim();

        return (
          <>
            {isMobile && (
              <div
                className={"panelOverlay " + (mobilePanelOpen ? "show" : "")}
                onClick={() => setMobilePanelOpen(false)}
              />
            )}

            <div className="toolbar">
              <button className={"toolBtn " + (tool==="select" ? "active" : "")} onClick={() => setTool("select")}>
                Select
              </button>
              <button className={"toolBtn " + (tool==="pan" ? "active" : "")} onClick={() => setTool("pan")}>
                Pan
              </button>
              <span className="tbDivider"></span>
              <button className={"toolBtn room " + (tool==="draw" ? "active" : "")} onClick={() => setTool("draw")}>
                Draw
              </button>
              <button className={"toolBtn elev " + (tool==="elev" ? "active" : "")} onClick={() => setTool("elev")}>
                Elevation
              </button>
              <button className={"toolBtn note " + (tool==="note" ? "active" : "")} onClick={() => setTool("note")}>
                Note
              </button>
              {isMobile && (
                <>
                  <span className="tbDivider"></span>
                  <button className="toolBtn" onClick={() => setMobilePanelOpen(true)}>Panel</button>
                </>
              )}
            </div>

            <div className="app">
              <div className="canvasZone" onWheel={onWheel}>
                <div
                  className="viewport"
                  ref={viewportRef}
                  onPointerDown={onPointerDown}
                  onPointerMove={onPointerMove}
                  onPointerUp={onPointerUp}
                  onPointerCancel={onPointerUp}
                >
                  <div
                    className="stage"
                    style={{
                      transform: `translate(${view.tx}px, ${view.ty}px) scale(${view.scale}) translate(${-SHEET.w/2}px, ${-SHEET.h/2}px)`
                    }}
                  >
                    <div className="sheet" style={{ "--sheet-width": `${SHEET.w}px`, "--sheet-height": `${SHEET.h}px` }}>
                      {/* Grid */}
                      <svg className="gridSvg" width={SHEET.w} height={SHEET.h}>
                        {Array.from({length: Math.floor(SHEET.w/10)+1}).map((_,i) => {
                          const x = i*10;
                          const isMajor = x % 50 === 0;
                          return <line key={"vx"+i} x1={x} y1={0} x2={x} y2={SHEET.h} className={isMajor ? "major":"minor"} />;
                        })}
                        {Array.from({length: Math.floor(SHEET.h/10)+1}).map((_,i) => {
                          const y = i*10;
                          const isMajor = y % 50 === 0;
                          return <line key={"hy"+i} x1={0} y1={y} x2={SHEET.w} y2={y} className={isMajor ? "major":"minor"} />;
                        })}
                      </svg>

                      {showHeatmap && elevPts.length > 1 && (
                        <svg className="heatSvg" width={SHEET.w} height={SHEET.h}>
                          <defs>
                            <filter id="heatBlur">
                              <feGaussianBlur stdDeviation="18" />
                            </filter>
                          </defs>
                          {elevPts.map(p => {
                            const color = elevColor(Number(p.reading));
                            return (
                              <circle
                                key={`heat-${p.id}`}
                                cx={p.x}
                                cy={p.y}
                                r={80}
                                fill={color}
                                opacity={0.22}
                                filter="url(#heatBlur)"
                              />
                            );
                          })}
                        </svg>
                      )}

                      <svg className="measureSvg" width={SHEET.w} height={SHEET.h}>
                        {measurements.map(m => (
                          <g key={m.id} onPointerDown={(e) => {
                            if(tool !== "select") return;
                            e.stopPropagation();
                            selectEntity("measure", m.id);
                          }}>
                            <line x1={m.x1} y1={m.y1} x2={m.x2} y2={m.y2} className="measureLine" />
                            <text
                              x={(m.x1 + m.x2) / 2}
                              y={(m.y1 + m.y2) / 2 - 6}
                              className="measureLabel"
                            >
                              {measurementText(m)}
                            </text>
                          </g>
                        ))}
                        {measureDraft && tool === "measure" && (
                          <g>
                            <line x1={measureDraft.x1} y1={measureDraft.y1} x2={measureDraft.x2} y2={measureDraft.y2} className="measureLine draft" />
                          </g>
                        )}
                      </svg>

                      {/* Spaces */}
                      {rooms.map(r => (
                        <div
                          key={r.id}
                          className={`spaceRect ${r.kind || "room"} ${r.locked ? "locked" : ""}`}
                          onPointerDown={(e) => {
                            if(tool !== "select") return;
                            e.stopPropagation();
                            selectEntity("room", r.id);
                          }}
                          style={{
                            left: r.cx,
                            top: r.cy,
                            width: r.w,
                            height: r.h
                          }}
                        >
                          <div className="roomLabel">
                            <span className="roomName">{r.name}</span>
                            <span className="roomMeta">{roomDimsText(r)}</span>
                            <span className="roomKind">{(r.kind || "room").toUpperCase()}</span>
                            {r.locked && <span className="roomKind">LOCKED</span>}
                          </div>
                        </div>
                      ))}

                      {/* Openings */}
                      {openings.map(o => (
                        <div
                          key={o.id}
                          className={`openingRect ${o.kind || ""} ${o.locked ? "locked" : ""}`}
                          onPointerDown={(e) => {
                            if(tool !== "select") return;
                            e.stopPropagation();
                            selectEntity("opening", o.id);
                          }}
                          style={{
                            left: o.x,
                            top: o.y,
                            width: o.w,
                            height: o.h
                          }}
                        >
                          <div className="fixtureLabel">{o.label}</div>
                        </div>
                      ))}

                      {/* Fixtures */}
                      {fixtures.map(f => (
                        <div
                          key={f.id}
                          className={`fixtureRect ${f.kind || ""} ${f.locked ? "locked" : ""}`}
                          onPointerDown={(e) => {
                            if(tool !== "select") return;
                            e.stopPropagation();
                            selectEntity("fixture", f.id);
                          }}
                          style={{
                            left: f.x,
                            top: f.y,
                            width: f.w,
                            height: f.h
                          }}
                        >
                          <div className="fixtureLabel">{f.label}</div>
                        </div>
                      ))}

                      {/* Elevation points */}
                      {elevPts.map(p => {
                        const value = Number(p.reading);
                        const cls = classifyElev(value);
                        const color = elevColor(value);
                        const delta = value - zeroRef;
                        const deltaText = `${delta >= 0 ? "+" : ""}${delta.toFixed(2)}`;
                        return (
                          <div key={p.id} style={{ position:"absolute", left:p.x, top:p.y }}>
                            <div
                              className="elevBadge"
                              onPointerDown={(e) => {
                                if(tool !== "select") return;
                                e.stopPropagation();
                                selectEntity("elev", p.id);
                              }}
                              style={{ left:0, top:0 }}
                            >
                              {value.toFixed(2)} <small>{cls.tag}</small>
                              <small>Î” {deltaText}</small>
                            </div>
                            <div
                              className="elevDot"
                              onPointerDown={(e) => {
                                if(tool !== "select") return;
                                e.stopPropagation();
                                selectEntity("elev", p.id);
                              }}
                              style={{ left:0, top:22, background: color }}
                            />
                          </div>
                        );
                      })}

                      {/* Notes */}
                      {notes.map(n => (
                        <div
                          key={n.id}
                          className="noteMarker"
                          title={n.text}
                          onPointerDown={(e) => {
                            if(tool !== "select") return;
                            e.stopPropagation();
                            selectEntity("note", n.id);
                          }}
                          style={{ left:n.x, top:n.y }}
                        >
                          N
                        </div>
                      ))}
                    </div>
                  </div>
                </div>

                <div className="navTools">
                  <div className="navCard">
                    <div className="navRow">
                      <div className="zBtns">
                        <button className="zBtn" onClick={zoomOut}>â€“</button>
                        <button className="zBtn" onClick={zoomIn}>+</button>
                        <button className="zBtn" onClick={zoomReset}>Reset</button>
                        <button className="zBtn" onClick={zoomFit}>Fit</button>
                      </div>
                      <div className="zReadout">{Math.round(view.scale*100)}%</div>
                    </div>
                    <div className="hint">
                      Tip: Use two fingers to pan/zoom on iPad. Use Select to move spaces, fixtures, and points. Lock items when finalized.
                    </div>
                  </div>
                </div>
              </div>

              <div className={panelClass}>
                <div className="pHeader">
                  <div className="titleWrap" style={{ minWidth:0 }}>
                    <div className="small">TitanFoundation</div>
                    <div className="big" title={projectName}>{projectName}</div>
                  </div>
                  <button className="collapseBtn" onClick={() => setPanelCollapsed(v => !v)} title="Collapse/Expand">
                    {panelCollapsed ? "Â»" : "Â«"}
                  </button>
                </div>

                <div className="pScroll">
                  <details className="section" open>
                    <summary>Project &amp; scale</summary>
                    <div className="sectionBody">
                      <div>
                        <label className="lbl">Project</label>
                        <input className="inp" value={projectName} onChange={(e)=>setProjectName(e.target.value)} placeholder="Enter Name" />
                      </div>
                      <div className="row">
                        <div>
                          <label className="lbl">Front faces</label>
                          <select value={frontFaces} onChange={(e)=>setFrontFaces(e.target.value)}>
                            {["North","South","East","West","Northeast","Northwest","Southeast","Southwest"].map(v => (
                              <option key={v} value={v}>{v}</option>
                            ))}
                          </select>
                        </div>
                        <div>
                          <label className="lbl">Scale</label>
                          <select value={scaleFtPerMajor} onChange={(e)=>setScaleFtPerMajor(Number(e.target.value))}>
                            {[2,5,10,15,20].map(v => (
                              <option key={v} value={v}>{v} ft / major grid</option>
                            ))}
                          </select>
                        </div>
                      </div>
                      <div className="row">
                        <button className="btn btnPrimary" onClick={() => saveState("manual")}>Save</button>
                        <button className="btn" onClick={loadState}>Load</button>
                      </div>
                      <div className="row">
                        <button className="btn" onClick={exportJson}>Export JSON</button>
                        <label className="btn" style={{ margin:0 }}>
                          Import JSON
                          <input type="file" accept="application/json" style={{ display:"none" }}
                            onChange={(e)=>importJson(e.target.files?.[0])}
                          />
                        </label>
                      </div>
                    </div>
                  </details>

                  <details className="section" open>
                    <summary>Inspection modes</summary>
                    <div className="sectionBody">
                      <div className="row">
                        <button className={"btn " + (tool==="select" ? "btnPrimary" : "")} onClick={() => setTool("select")}>Select</button>
                        <button className={"btn " + (tool==="pan" ? "btnPrimary" : "")} onClick={() => setTool("pan")}>Pan</button>
                      </div>
                      <div className="row">
                        <button className={"btn " + (tool==="draw" ? "btnPrimary" : "")} onClick={() => setTool("draw")}>Draw</button>
                        <button className={"btn " + (tool==="elev" ? "btnPrimary" : "")} onClick={() => setTool("elev")}>Elevation</button>
                      </div>
                      <div className="row">
                        <button className={"btn " + (tool==="measure" ? "btnPrimary" : "")} onClick={() => setTool("measure")}>Measure</button>
                        <button className={"btn " + (tool==="note" ? "btnPrimary" : "")} onClick={() => setTool("note")}>Note</button>
                      </div>
                      <div className="tiny">Active tool: <b>{tool}</b></div>
                    </div>
                  </details>

                  <details className="section" open>
                    <summary>Draw settings</summary>
                    <div className="sectionBody">
                      <div>
                        <label className="lbl">Draw type</label>
                        <select value={drawType} onChange={(e)=>setDrawType(e.target.value)}>
                          {[
                            ["room","Room"],
                            ["boundary","Boundary"],
                            ["hallway","Hallway"],
                            ["partial","Partial / offset"]
                          ].map(([v,label]) => (
                            <option key={v} value={v}>{label}</option>
                          ))}
                        </select>
                      </div>
                      <div className="tiny">
                        Use Boundary for exterior property limits, Hallway for connectors, Partial for half walls or incomplete spans.
                      </div>
                    </div>
                  </details>

                  <details className="section" open>
                    <summary>Elevation capture &amp; grading</summary>
                    <div className="sectionBody">
                      <div className="row">
                        <div>
                          <label className="lbl">Reading</label>
                          <input
                            className="inp"
                            value={draftElevation.reading}
                            onChange={(e)=>setDraftElevation(prev => ({ ...prev, reading: e.target.value }))}
                          />
                        </div>
                        <div>
                          <label className="lbl">Note</label>
                          <input
                            className="inp"
                            value={draftElevation.note}
                            onChange={(e)=>setDraftElevation(prev => ({ ...prev, note: e.target.value }))}
                            placeholder="e.g. North wall"
                          />
                        </div>
                      </div>
                      <div className="row">
                        <button className={"btn " + (tool==="elev" ? "btnPrimary" : "")} onClick={() => setTool("elev")}>Use Elevation Tool</button>
                        <button className="btn" onClick={() => setShowHeatmap(v => !v)}>{showHeatmap ? "Hide Heatmap" : "Show Heatmap"}</button>
                      </div>
                      {elevSummary.min == null ? (
                        <div className="tiny">No elevation points yet. Place readings around the perimeter and interior.</div>
                      ) : (
                        <>
                          <div className="row">
                            <div className="pill">Min: {elevSummary.min.toFixed(2)}</div>
                            <div className="pill">Max: {elevSummary.max.toFixed(2)}</div>
                            <div className="pill">Diff: {elevSummary.diff.toFixed(2)}</div>
                            <div className="pill">Zero: {zeroRef.toFixed(2)}</div>
                          </div>
                          <div className="row">
                            <label className="lbl" style={{ margin:0 }}>Zero reference</label>
                            <select value={zeroMode} onChange={(e)=>setZeroMode(e.target.value)}>
                              <option value="auto">Auto (midpoint)</option>
                              <option value="custom">Custom</option>
                            </select>
                          </div>
                          {zeroMode === "custom" && (
                            <input
                              className="inp"
                              value={customZero}
                              onChange={(e)=>setCustomZero(e.target.value)}
                              placeholder="Enter zero reference"
                            />
                          )}
                          <div className="tiny">
                            Heatmap and HIGH/MID/LOW labels scale from lowest to highest readings so you can spot relative movement quickly.
                          </div>
                        </>
                      )}
                    </div>
                  </details>

                  <details className="section">
                    <summary>Field notes</summary>
                    <div className="sectionBody">
                      <label className="lbl">Default note</label>
                      <textarea value={draftNote} onChange={(e)=>setDraftNote(e.target.value)} placeholder="Observation or reference" />
                      <button className={"btn " + (tool==="note" ? "btnPrimary" : "")} onClick={() => setTool("note")}>Use Note Tool</button>
                      <div className="tiny">Attach photo links after placing a note (selected item).</div>
                    </div>
                  </details>

                  <details className="section">
                    <summary>Openings &amp; obstructions</summary>
                    <div className="sectionBody">
                      <div>
                        <label className="lbl">Openings / half walls</label>
                        <select
                          value={draftOpening.kind}
                          onChange={(e)=>setDraftOpening(prev => ({ ...prev, kind: e.target.value, label: e.target.value }))}
                        >
                          {["Door","Window","Half Wall","Garage Opening","Stair Opening"].map(v => (
                            <option key={v} value={v}>{v}</option>
                          ))}
                        </select>
                        <input
                          className="inp"
                          style={{ marginTop:8 }}
                          value={draftOpening.label}
                          onChange={(e)=>setDraftOpening(prev => ({ ...prev, label: e.target.value }))}
                          placeholder="Label"
                        />
                        <div className="row" style={{ marginTop:8 }}>
                          <input className="inp" value={draftOpening.w} onChange={(e)=>setDraftOpening(prev => ({ ...prev, w:e.target.value }))} placeholder="Width (px)" />
                          <input className="inp" value={draftOpening.h} onChange={(e)=>setDraftOpening(prev => ({ ...prev, h:e.target.value }))} placeholder="Height (px)" />
                        </div>
                        <button className={"btn " + (tool==="opening" ? "btnPrimary" : "")} onClick={() => setTool("opening")}>Place Opening</button>
                      </div>
                      <div className="hr"></div>
                      <div>
                        <label className="lbl">Fixtures / obstructions</label>
                        <select
                          value={draftFixture.kind}
                          onChange={(e)=>setDraftFixture(prev => ({ ...prev, kind: e.target.value, label: e.target.value }))}
                        >
                          {["Toilet","Sink","Tub","Shower","Washer","Dryer","Refrigerator","Table","Bed","Counter","Furnace","Water Heater","Column","Custom"].map(v => (
                            <option key={v} value={v}>{v}</option>
                          ))}
                        </select>
                        <input
                          className="inp"
                          style={{ marginTop:8 }}
                          value={draftFixture.label}
                          onChange={(e)=>setDraftFixture(prev => ({ ...prev, label: e.target.value }))}
                          placeholder="Label"
                        />
                        <div className="row" style={{ marginTop:8 }}>
                          <input className="inp" value={draftFixture.w} onChange={(e)=>setDraftFixture(prev => ({ ...prev, w:e.target.value }))} placeholder="Width (px)" />
                          <input className="inp" value={draftFixture.h} onChange={(e)=>setDraftFixture(prev => ({ ...prev, h:e.target.value }))} placeholder="Height (px)" />
                        </div>
                        <button className={"btn " + (tool==="fixture" ? "btnPrimary" : "")} onClick={() => setTool("fixture")}>Place Fixture</button>
                      </div>
                    </div>
                  </details>

                  <details className="section">
                    <summary>Measurements</summary>
                    <div className="sectionBody">
                      <div className="tiny">Click two points to measure. Measurements follow the scale grid.</div>
                      <div className="row">
                        <button className={"btn " + (tool==="measure" ? "btnPrimary" : "")} onClick={() => setTool("measure")}>Use Measure Tool</button>
                        <button className="btn btnDanger" onClick={() => setMeasurements([])}>Clear</button>
                      </div>
                      {measureDraft && (
                        <button className="btn" onClick={() => setMeasureDraft(null)}>Cancel pending measurement</button>
                      )}
                      <div className="tiny">Measurements: {measurements.length}</div>
                    </div>
                  </details>

                  <details className="section">
                    <summary>Items</summary>
                    <div className="sectionBody">
                      <div className="tiny">Select an item (or tap one on the sheet) to edit its details here.</div>

                      <div className="tiny" style={{ fontWeight:1200, margin:"8px 0" }}>Spaces ({rooms.length})</div>
                      {rooms.length ? rooms.map(r => (
                        <div
                          key={r.id}
                          className={"listItem " + (selected.type==="room" && selected.id===r.id ? "selected":"")}
                          onClick={()=>selectEntity("room", r.id)}
                        >
                          <div style={{ minWidth:0 }}>
                            <b>{r.name}</b>
                            <span>{roomDimsText(r)} â€¢ {(r.kind || "room")}</span>
                          </div>
                          <div className="pill">Space</div>
                        </div>
                      )) : <div className="tiny">No spaces yet. Use â€œDrawâ€.</div>}

                      <div className="hr"></div>

                      <div className="tiny" style={{ fontWeight:1200, margin:"8px 0" }}>Openings ({openings.length})</div>
                      {openings.length ? openings.map(o => (
                        <div
                          key={o.id}
                          className={"listItem " + (selected.type==="opening" && selected.id===o.id ? "selected":"")}
                          onClick={()=>selectEntity("opening", o.id)}
                        >
                          <div style={{ minWidth:0 }}>
                            <b>{o.label}</b>
                            <span>{o.kind}</span>
                          </div>
                          <div className="pill">Opening</div>
                        </div>
                      )) : <div className="tiny">No openings placed.</div>}

                      <div className="hr"></div>

                      <div className="tiny" style={{ fontWeight:1200, margin:"8px 0" }}>Fixtures ({fixtures.length})</div>
                      {fixtures.length ? fixtures.map(f => (
                        <div
                          key={f.id}
                          className={"listItem " + (selected.type==="fixture" && selected.id===f.id ? "selected":"")}
                          onClick={()=>selectEntity("fixture", f.id)}
                        >
                          <div style={{ minWidth:0 }}>
                            <b>{f.label}</b>
                            <span>{f.kind}</span>
                          </div>
                          <div className="pill">Fixture</div>
                        </div>
                      )) : <div className="tiny">No fixtures placed.</div>}

                      <div className="hr"></div>

                      <div className="tiny" style={{ fontWeight:1200, margin:"8px 0" }}>Elevations ({elevPts.length})</div>
                      {elevPts.length ? elevPts.map(p => (
                        <div
                          key={p.id}
                          className={"listItem " + (selected.type==="elev" && selected.id===p.id ? "selected":"")}
                          onClick={()=>selectEntity("elev", p.id)}
                        >
                          <div style={{ minWidth:0 }}>
                            <b>{Number(p.reading).toFixed(2)}</b>
                            <span>{(p.note || "").trim() ? p.note : "No note"}</span>
                          </div>
                          <div className="pill">Elev</div>
                        </div>
                      )) : <div className="tiny">No elevations yet.</div>}

                      <div className="hr"></div>

                      <div className="tiny" style={{ fontWeight:1200, margin:"8px 0" }}>Notes ({notes.length})</div>
                      {notes.length ? notes.map(n => (
                        <div
                          key={n.id}
                          className={"listItem " + (selected.type==="note" && selected.id===n.id ? "selected":"")}
                          onClick={()=>selectEntity("note", n.id)}
                        >
                          <div style={{ minWidth:0 }}>
                            <b>Note</b>
                            <span>{n.text}</span>
                          </div>
                          <div className="pill">Note</div>
                        </div>
                      )) : <div className="tiny">No notes yet.</div>}

                      <div className="hr"></div>

                      <div className="tiny" style={{ fontWeight:1200, margin:"8px 0" }}>Measurements ({measurements.length})</div>
                      {measurements.length ? measurements.map(m => (
                        <div
                          key={m.id}
                          className={"listItem " + (selected.type==="measure" && selected.id===m.id ? "selected":"")}
                          onClick={()=>selectEntity("measure", m.id)}
                        >
                          <div style={{ minWidth:0 }}>
                            <b>{measurementText(m)}</b>
                            <span>Segment</span>
                          </div>
                          <div className="pill">Measure</div>
                        </div>
                      )) : <div className="tiny">No measurements yet.</div>}
                    </div>
                  </details>

                  <details className="section">
                    <summary>Selected item</summary>
                    <div className="sectionBody">
                      {!selectedEntity ? (
                        <div className="tiny">Nothing selected.</div>
                      ) : (
                        <>
                          {selected.type === "room" && (
                            <>
                              <label className="lbl">Name</label>
                              <input className="inp" value={selectedEntity.name} onChange={(e)=>updateSelected({ name:e.target.value })} />
                              <label className="lbl" style={{ marginTop:8 }}>Kind</label>
                              <select value={selectedEntity.kind || "room"} onChange={(e)=>updateSelected({ kind:e.target.value })}>
                                {["room","boundary","hallway","partial"].map(v => (
                                  <option key={v} value={v}>{v}</option>
                                ))}
                              </select>
                              <label style={{ display:"flex", gap:10, alignItems:"center", fontSize:13, fontWeight:1000, marginTop:8 }}>
                                <input type="checkbox" checked={!!selectedEntity.locked} onChange={(e)=>updateSelected({ locked:e.target.checked })} />
                                Lock position
                              </label>
                              <div className="tiny">Size follows the grid scale for quick takeoffs.</div>
                            </>
                          )}

                          {selected.type === "elev" && (
                            <>
                              <label className="lbl">Elevation reading</label>
                              <input
                                className="inp"
                                value={selectedEntity.reading}
                                onChange={(e)=>{
                                  const v = Number(e.target.value);
                                  updateSelected({ reading: Number.isFinite(v) ? v : selectedEntity.reading });
                                }}
                              />
                              <label className="lbl" style={{ marginTop:10 }}>Note</label>
                              <textarea value={selectedEntity.note || ""} onChange={(e)=>updateSelected({ note:e.target.value })} />
                            </>
                          )}

                          {selected.type === "note" && (
                            <>
                              <label className="lbl">Note text</label>
                              <textarea value={selectedEntity.text} onChange={(e)=>updateSelected({ text:e.target.value })} />
                              <label className="lbl" style={{ marginTop:10 }}>Photo URL</label>
                              <input className="inp" value={selectedEntity.photo || ""} onChange={(e)=>updateSelected({ photo:e.target.value })} placeholder="Paste image link" />
                            </>
                          )}

                          {selected.type === "fixture" && (
                            <>
                              <label className="lbl">Label</label>
                              <input className="inp" value={selectedEntity.label} onChange={(e)=>updateSelected({ label:e.target.value })} />
                              <label className="lbl" style={{ marginTop:8 }}>Kind</label>
                              <input className="inp" value={selectedEntity.kind} onChange={(e)=>updateSelected({ kind:e.target.value })} />
                              <div className="row">
                                <input className="inp" value={selectedEntity.w} onChange={(e)=>updateSelected({ w:e.target.value })} placeholder="Width" />
                                <input className="inp" value={selectedEntity.h} onChange={(e)=>updateSelected({ h:e.target.value })} placeholder="Height" />
                              </div>
                              <label style={{ display:"flex", gap:10, alignItems:"center", fontSize:13, fontWeight:1000 }}>
                                <input type="checkbox" checked={!!selectedEntity.locked} onChange={(e)=>updateSelected({ locked:e.target.checked })} />
                                Lock position
                              </label>
                            </>
                          )}

                          {selected.type === "opening" && (
                            <>
                              <label className="lbl">Label</label>
                              <input className="inp" value={selectedEntity.label} onChange={(e)=>updateSelected({ label:e.target.value })} />
                              <label className="lbl" style={{ marginTop:8 }}>Kind</label>
                              <input className="inp" value={selectedEntity.kind} onChange={(e)=>updateSelected({ kind:e.target.value })} />
                              <div className="row">
                                <input className="inp" value={selectedEntity.w} onChange={(e)=>updateSelected({ w:e.target.value })} placeholder="Width" />
                                <input className="inp" value={selectedEntity.h} onChange={(e)=>updateSelected({ h:e.target.value })} placeholder="Height" />
                              </div>
                              <label style={{ display:"flex", gap:10, alignItems:"center", fontSize:13, fontWeight:1000 }}>
                                <input type="checkbox" checked={!!selectedEntity.locked} onChange={(e)=>updateSelected({ locked:e.target.checked })} />
                                Lock position
                              </label>
                            </>
                          )}

                          {selected.type === "measure" && (
                            <div className="tiny">Measurement length: {measurementText(selectedEntity)}</div>
                          )}

                          <div className="row" style={{ marginTop:10 }}>
                            <button className="btn btnDanger" onClick={deleteSelected}>Delete</button>
                            <button className="btn" onClick={()=>setSelected({ type:null, id:null })}>Clear</button>
                          </div>
                        </>
                      )}
                    </div>
                  </details>

                  <details className="section">
                    <summary>Plumbing leak indicators</summary>
                    <div className="sectionBody">
                      <div className="tiny">Field prompts to support your site narrative.</div>
                      <div style={{ marginTop:10, display:"grid", gap:8 }}>
                        {[
                          ["activeLeakReported","Active leak reported (occupant / visible)"],
                          ["plumbingSupplyNearby","Plumbing supply line nearby"],
                          ["drainLineNearby","Drain / sanitary line nearby"],
                          ["stainingObserved","Staining / efflorescence observed"],
                          ["elevatedMoistureReadings","Elevated moisture readings observed"]
                        ].map(([k,label]) => (
                          <label key={k} style={{ display:"flex", gap:10, alignItems:"center", fontSize:13, fontWeight:1000 }}>
                            <input
                              type="checkbox"
                              checked={!!leak[k]}
                              onChange={(e)=>setLeak(prev=>({ ...prev, [k]: e.target.checked }))}
                            />
                            {label}
                          </label>
                        ))}
                      </div>
                      <div style={{ marginTop:10 }}>
                        <label className="lbl">Notes</label>
                        <textarea
                          value={leak.notes}
                          onChange={(e)=>setLeak(prev=>({ ...prev, notes:e.target.value }))}
                          placeholder="Brief notes (locations, fixtures, timing, actions taken, etc.)"
                        />
                      </div>
                    </div>
                  </details>

                  <details className="section">
                    <summary>Quick reset</summary>
                    <div className="sectionBody">
                      <div className="row">
                        <button className="btn btnDanger" onClick={()=>{
                          if(!confirm("Clear the entire sheet?")) return;
                          setRooms([]); setElevPts([]); setNotes([]); setFixtures([]); setOpenings([]); setMeasurements([]);
                          setSelected({ type:null, id:null });
                        }}>
                          Clear Sheet
                        </button>
                        <button className="btn" onClick={() => zoomFit()}>Fit View</button>
                      </div>
                      <div className="tiny">
                        Clearing the sheet does not clear the leak indicators or project header.
                      </div>
                    </div>
                  </details>

                </div>
              </div>
            </div>

            {isMobile && (
              <div className="mobileDock">
                <button className="btn btnPrimary" onClick={()=>setMobilePanelOpen(true)}>Open Panel</button>
                <button className="btn" onClick={()=>setTool("select")}>Select</button>
                <button className="btn" onClick={()=>setTool("pan")}>Pan</button>
              </div>
            )}
          </>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
    </script>
  </body>
</html>
